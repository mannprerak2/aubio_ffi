// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Raw bindings for aubio
class AubioBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  AubioBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  AubioBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// fvec_t buffer creation function
  ///
  /// \param length the length of the buffer to create
  ffi.Pointer<fvec_t> new_fvec(
    int length,
  ) {
    return _new_fvec(
      length,
    );
  }

  late final _new_fvecPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<fvec_t> Function(uint_t)>>(
          'new_fvec');
  late final _new_fvec =
      _new_fvecPtr.asFunction<ffi.Pointer<fvec_t> Function(int)>();

  /// fvec_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_fvec()
  void del_fvec(
    ffi.Pointer<fvec_t> s,
  ) {
    return _del_fvec(
      s,
    );
  }

  late final _del_fvecPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'del_fvec');
  late final _del_fvec =
      _del_fvecPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// read sample value in a buffer
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  double fvec_get_sample(
    ffi.Pointer<fvec_t> s,
    int position,
  ) {
    return _fvec_get_sample(
      s,
      position,
    );
  }

  late final _fvec_get_samplePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>, uint_t)>>(
          'fvec_get_sample');
  late final _fvec_get_sample = _fvec_get_samplePtr
      .asFunction<double Function(ffi.Pointer<fvec_t>, int)>();

  /// write sample value in a buffer
  ///
  /// \param s vector to write to
  /// \param data value to write in s->data[position]
  /// \param position sample position to write to
  void fvec_set_sample(
    ffi.Pointer<fvec_t> s,
    double data,
    int position,
  ) {
    return _fvec_set_sample(
      s,
      data,
      position,
    );
  }

  late final _fvec_set_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<fvec_t>, smpl_t, uint_t)>>('fvec_set_sample');
  late final _fvec_set_sample = _fvec_set_samplePtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, double, int)>();

  /// read data from a buffer
  ///
  /// \param s vector to read from
  ffi.Pointer<smpl_t> fvec_get_data(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_get_data(
      s,
    );
  }

  late final _fvec_get_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<smpl_t> Function(ffi.Pointer<fvec_t>)>>('fvec_get_data');
  late final _fvec_get_data = _fvec_get_dataPtr
      .asFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<fvec_t>)>();

  /// print out fvec data
  ///
  /// \param s vector to print out
  void fvec_print(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_print(
      s,
    );
  }

  late final _fvec_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_print');
  late final _fvec_print =
      _fvec_printPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// set all elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void fvec_set_all(
    ffi.Pointer<fvec_t> s,
    double val,
  ) {
    return _fvec_set_all(
      s,
      val,
    );
  }

  late final _fvec_set_allPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>>(
      'fvec_set_all');
  late final _fvec_set_all =
      _fvec_set_allPtr.asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// set all elements to zero
  ///
  /// \param s vector to modify
  void fvec_zeros(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_zeros(
      s,
    );
  }

  late final _fvec_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_zeros');
  late final _fvec_zeros =
      _fvec_zerosPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// set all elements to ones
  ///
  /// \param s vector to modify
  void fvec_ones(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_ones(
      s,
    );
  }

  late final _fvec_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_ones');
  late final _fvec_ones =
      _fvec_onesPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// revert order of vector elements
  ///
  /// \param s vector to revert
  void fvec_rev(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_rev(
      s,
    );
  }

  late final _fvec_revPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_rev');
  late final _fvec_rev =
      _fvec_revPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// apply weight to vector
  ///
  /// If the weight vector is longer than s, only the first elements are used. If
  /// the weight vector is shorter than s, the last elements of s are not weighted.
  ///
  /// \param s vector to weight
  /// \param weight weighting coefficients
  void fvec_weight(
    ffi.Pointer<fvec_t> s,
    ffi.Pointer<fvec_t> weight,
  ) {
    return _fvec_weight(
      s,
      weight,
    );
  }

  late final _fvec_weightPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>>('fvec_weight');
  late final _fvec_weight = _fvec_weightPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>();

  /// make a copy of a vector
  ///
  /// \param s source vector
  /// \param t vector to copy to
  void fvec_copy(
    ffi.Pointer<fvec_t> s,
    ffi.Pointer<fvec_t> t,
  ) {
    return _fvec_copy(
      s,
      t,
    );
  }

  late final _fvec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>>('fvec_copy');
  late final _fvec_copy = _fvec_copyPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>();

  /// make a copy of a vector, applying weights to each element
  ///
  /// \param in input vector
  /// \param weight weights vector
  /// \param out output vector
  void fvec_weighted_copy(
    ffi.Pointer<fvec_t> in1,
    ffi.Pointer<fvec_t> weight,
    ffi.Pointer<fvec_t> out,
  ) {
    return _fvec_weighted_copy(
      in1,
      weight,
      out,
    );
  }

  late final _fvec_weighted_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('fvec_weighted_copy');
  late final _fvec_weighted_copy = _fvec_weighted_copyPtr.asFunction<
      void Function(
          ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>();

  /// cvec_t buffer creation function
  ///
  /// This function creates a cvec_t structure holding two arrays of size
  /// [length/2+1], corresponding to the norm and phase values of the
  /// spectral frame. The length stored in the structure is the actual size of both
  /// arrays, not the length of the complex and symmetrical vector, specified as
  /// creation argument.
  ///
  /// \param length the length of the buffer to create
  ffi.Pointer<cvec_t> new_cvec(
    int length,
  ) {
    return _new_cvec(
      length,
    );
  }

  late final _new_cvecPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<cvec_t> Function(uint_t)>>(
          'new_cvec');
  late final _new_cvec =
      _new_cvecPtr.asFunction<ffi.Pointer<cvec_t> Function(int)>();

  /// cvec_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_cvec()
  void del_cvec(
    ffi.Pointer<cvec_t> s,
  ) {
    return _del_cvec(
      s,
    );
  }

  late final _del_cvecPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
          'del_cvec');
  late final _del_cvec =
      _del_cvecPtr.asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// write norm value in a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// s->norm[position] = val;
  /// \endcode
  ///
  /// \param s vector to write to
  /// \param val norm value to write in s->norm[position]
  /// \param position sample position to write to
  void cvec_norm_set_sample(
    ffi.Pointer<cvec_t> s,
    double val,
    int position,
  ) {
    return _cvec_norm_set_sample(
      s,
      val,
      position,
    );
  }

  late final _cvec_norm_set_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<cvec_t>, smpl_t, uint_t)>>('cvec_norm_set_sample');
  late final _cvec_norm_set_sample = _cvec_norm_set_samplePtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, double, int)>();

  /// write phase value in a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// s->phas[position] = val;
  /// \endcode
  ///
  /// \param s vector to write to
  /// \param val phase value to write in s->phas[position]
  /// \param position sample position to write to
  void cvec_phas_set_sample(
    ffi.Pointer<cvec_t> s,
    double val,
    int position,
  ) {
    return _cvec_phas_set_sample(
      s,
      val,
      position,
    );
  }

  late final _cvec_phas_set_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<cvec_t>, smpl_t, uint_t)>>('cvec_phas_set_sample');
  late final _cvec_phas_set_sample = _cvec_phas_set_samplePtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, double, int)>();

  /// read norm value from a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// smpl_t foo = s->norm[position];
  /// \endcode
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  double cvec_norm_get_sample(
    ffi.Pointer<cvec_t> s,
    int position,
  ) {
    return _cvec_norm_get_sample(
      s,
      position,
    );
  }

  late final _cvec_norm_get_samplePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<cvec_t>, uint_t)>>(
          'cvec_norm_get_sample');
  late final _cvec_norm_get_sample = _cvec_norm_get_samplePtr
      .asFunction<double Function(ffi.Pointer<cvec_t>, int)>();

  /// read phase value from a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// smpl_t foo = s->phas[position];
  /// \endcode
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  /// \returns the value of the sample at position
  double cvec_phas_get_sample(
    ffi.Pointer<cvec_t> s,
    int position,
  ) {
    return _cvec_phas_get_sample(
      s,
      position,
    );
  }

  late final _cvec_phas_get_samplePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<cvec_t>, uint_t)>>(
          'cvec_phas_get_sample');
  late final _cvec_phas_get_sample = _cvec_phas_get_samplePtr
      .asFunction<double Function(ffi.Pointer<cvec_t>, int)>();

  /// read norm data from a complex buffer
  ///
  /// \code
  /// smpl_t *data = s->norm;
  /// \endcode
  ///
  /// \param s vector to read from
  ffi.Pointer<smpl_t> cvec_norm_get_data(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_norm_get_data(
      s,
    );
  }

  late final _cvec_norm_get_dataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<cvec_t>)>>(
      'cvec_norm_get_data');
  late final _cvec_norm_get_data = _cvec_norm_get_dataPtr
      .asFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<cvec_t>)>();

  /// read phase data from a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// smpl_t *data = s->phas;
  /// \endcode
  ///
  /// \param s vector to read from
  ffi.Pointer<smpl_t> cvec_phas_get_data(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_phas_get_data(
      s,
    );
  }

  late final _cvec_phas_get_dataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<cvec_t>)>>(
      'cvec_phas_get_data');
  late final _cvec_phas_get_data = _cvec_phas_get_dataPtr
      .asFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<cvec_t>)>();

  /// print out cvec data
  ///
  /// \param s vector to print out
  void cvec_print(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_print(
      s,
    );
  }

  late final _cvec_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
          'cvec_print');
  late final _cvec_print =
      _cvec_printPtr.asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// make a copy of a vector
  ///
  /// \param s source vector
  /// \param t vector to copy to
  void cvec_copy(
    ffi.Pointer<cvec_t> s,
    ffi.Pointer<cvec_t> t,
  ) {
    return _cvec_copy(
      s,
      t,
    );
  }

  late final _cvec_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<cvec_t>, ffi.Pointer<cvec_t>)>>('cvec_copy');
  late final _cvec_copy = _cvec_copyPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, ffi.Pointer<cvec_t>)>();

  /// set all norm elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void cvec_norm_set_all(
    ffi.Pointer<cvec_t> s,
    double val,
  ) {
    return _cvec_norm_set_all(
      s,
      val,
    );
  }

  late final _cvec_norm_set_allPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>, smpl_t)>>(
      'cvec_norm_set_all');
  late final _cvec_norm_set_all = _cvec_norm_set_allPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, double)>();

  /// set all norm elements to zero
  ///
  /// \param s vector to modify
  void cvec_norm_zeros(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_norm_zeros(
      s,
    );
  }

  late final _cvec_norm_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
          'cvec_norm_zeros');
  late final _cvec_norm_zeros =
      _cvec_norm_zerosPtr.asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// set all norm elements to one
  ///
  /// \param s vector to modify
  void cvec_norm_ones(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_norm_ones(
      s,
    );
  }

  late final _cvec_norm_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
          'cvec_norm_ones');
  late final _cvec_norm_ones =
      _cvec_norm_onesPtr.asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// set all phase elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void cvec_phas_set_all(
    ffi.Pointer<cvec_t> s,
    double val,
  ) {
    return _cvec_phas_set_all(
      s,
      val,
    );
  }

  late final _cvec_phas_set_allPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>, smpl_t)>>(
      'cvec_phas_set_all');
  late final _cvec_phas_set_all = _cvec_phas_set_allPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, double)>();

  /// set all phase elements to zero
  ///
  /// \param s vector to modify
  void cvec_phas_zeros(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_phas_zeros(
      s,
    );
  }

  late final _cvec_phas_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
          'cvec_phas_zeros');
  late final _cvec_phas_zeros =
      _cvec_phas_zerosPtr.asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// set all phase elements to one
  ///
  /// \param s vector to modify
  void cvec_phas_ones(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_phas_ones(
      s,
    );
  }

  late final _cvec_phas_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
          'cvec_phas_ones');
  late final _cvec_phas_ones =
      _cvec_phas_onesPtr.asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// set all norm and phas elements to zero
  ///
  /// \param s vector to modify
  void cvec_zeros(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_zeros(
      s,
    );
  }

  late final _cvec_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
          'cvec_zeros');
  late final _cvec_zeros =
      _cvec_zerosPtr.asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// take logarithmic magnitude
  ///
  /// \param s input cvec to compress
  /// \param lambda value to use for normalisation
  ///
  /// \f$ S_k = log( \lambda * S_k + 1 ) \f$
  void cvec_logmag(
    ffi.Pointer<cvec_t> s,
    double lambda,
  ) {
    return _cvec_logmag(
      s,
      lambda,
    );
  }

  late final _cvec_logmagPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>, smpl_t)>>(
      'cvec_logmag');
  late final _cvec_logmag =
      _cvec_logmagPtr.asFunction<void Function(ffi.Pointer<cvec_t>, double)>();

  /// lvec_t buffer creation function
  ///
  /// \param length the length of the buffer to create
  ffi.Pointer<lvec_t> new_lvec(
    int length,
  ) {
    return _new_lvec(
      length,
    );
  }

  late final _new_lvecPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lvec_t> Function(uint_t)>>(
          'new_lvec');
  late final _new_lvec =
      _new_lvecPtr.asFunction<ffi.Pointer<lvec_t> Function(int)>();

  /// lvec_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_lvec()
  void del_lvec(
    ffi.Pointer<lvec_t> s,
  ) {
    return _del_lvec(
      s,
    );
  }

  late final _del_lvecPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>)>>(
          'del_lvec');
  late final _del_lvec =
      _del_lvecPtr.asFunction<void Function(ffi.Pointer<lvec_t>)>();

  /// read sample value in a buffer
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  double lvec_get_sample(
    ffi.Pointer<lvec_t> s,
    int position,
  ) {
    return _lvec_get_sample(
      s,
      position,
    );
  }

  late final _lvec_get_samplePtr =
      _lookup<ffi.NativeFunction<lsmp_t Function(ffi.Pointer<lvec_t>, uint_t)>>(
          'lvec_get_sample');
  late final _lvec_get_sample = _lvec_get_samplePtr
      .asFunction<double Function(ffi.Pointer<lvec_t>, int)>();

  /// write sample value in a buffer
  ///
  /// \param s vector to write to
  /// \param data value to write in s->data[position]
  /// \param position sample position to write to
  void lvec_set_sample(
    ffi.Pointer<lvec_t> s,
    double data,
    int position,
  ) {
    return _lvec_set_sample(
      s,
      data,
      position,
    );
  }

  late final _lvec_set_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lvec_t>, lsmp_t, uint_t)>>('lvec_set_sample');
  late final _lvec_set_sample = _lvec_set_samplePtr
      .asFunction<void Function(ffi.Pointer<lvec_t>, double, int)>();

  /// read data from a buffer
  ///
  /// \param s vector to read from
  ffi.Pointer<lsmp_t> lvec_get_data(
    ffi.Pointer<lvec_t> s,
  ) {
    return _lvec_get_data(
      s,
    );
  }

  late final _lvec_get_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lsmp_t> Function(ffi.Pointer<lvec_t>)>>('lvec_get_data');
  late final _lvec_get_data = _lvec_get_dataPtr
      .asFunction<ffi.Pointer<lsmp_t> Function(ffi.Pointer<lvec_t>)>();

  /// print out lvec data
  ///
  /// \param s vector to print out
  void lvec_print(
    ffi.Pointer<lvec_t> s,
  ) {
    return _lvec_print(
      s,
    );
  }

  late final _lvec_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>)>>(
          'lvec_print');
  late final _lvec_print =
      _lvec_printPtr.asFunction<void Function(ffi.Pointer<lvec_t>)>();

  /// set all elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void lvec_set_all(
    ffi.Pointer<lvec_t> s,
    double val,
  ) {
    return _lvec_set_all(
      s,
      val,
    );
  }

  late final _lvec_set_allPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>, smpl_t)>>(
      'lvec_set_all');
  late final _lvec_set_all =
      _lvec_set_allPtr.asFunction<void Function(ffi.Pointer<lvec_t>, double)>();

  /// set all elements to zero
  ///
  /// \param s vector to modify
  void lvec_zeros(
    ffi.Pointer<lvec_t> s,
  ) {
    return _lvec_zeros(
      s,
    );
  }

  late final _lvec_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>)>>(
          'lvec_zeros');
  late final _lvec_zeros =
      _lvec_zerosPtr.asFunction<void Function(ffi.Pointer<lvec_t>)>();

  /// set all elements to ones
  ///
  /// \param s vector to modify
  void lvec_ones(
    ffi.Pointer<lvec_t> s,
  ) {
    return _lvec_ones(
      s,
    );
  }

  late final _lvec_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>)>>(
          'lvec_ones');
  late final _lvec_ones =
      _lvec_onesPtr.asFunction<void Function(ffi.Pointer<lvec_t>)>();

  /// fmat_t buffer creation function
  ///
  /// \param length the length of the matrix to create
  /// \param height the height of the matrix to create
  ffi.Pointer<fmat_t> new_fmat(
    int height,
    int length,
  ) {
    return _new_fmat(
      height,
      length,
    );
  }

  late final _new_fmatPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<fmat_t> Function(uint_t, uint_t)>>(
          'new_fmat');
  late final _new_fmat =
      _new_fmatPtr.asFunction<ffi.Pointer<fmat_t> Function(int, int)>();

  /// fmat_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_fmat()
  void del_fmat(
    ffi.Pointer<fmat_t> s,
  ) {
    return _del_fmat(
      s,
    );
  }

  late final _del_fmatPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
          'del_fmat');
  late final _del_fmat =
      _del_fmatPtr.asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// read sample value in a buffer
  ///
  /// \param s vector to read from
  /// \param channel channel to read from
  /// \param position sample position to read from
  double fmat_get_sample(
    ffi.Pointer<fmat_t> s,
    int channel,
    int position,
  ) {
    return _fmat_get_sample(
      s,
      channel,
      position,
    );
  }

  late final _fmat_get_samplePtr = _lookup<
      ffi.NativeFunction<
          smpl_t Function(
              ffi.Pointer<fmat_t>, uint_t, uint_t)>>('fmat_get_sample');
  late final _fmat_get_sample = _fmat_get_samplePtr
      .asFunction<double Function(ffi.Pointer<fmat_t>, int, int)>();

  /// write sample value in a buffer
  ///
  /// \param s vector to write to
  /// \param data value to write in s->data[channel][position]
  /// \param channel channel to write to
  /// \param position sample position to write to
  void fmat_set_sample(
    ffi.Pointer<fmat_t> s,
    double data,
    int channel,
    int position,
  ) {
    return _fmat_set_sample(
      s,
      data,
      channel,
      position,
    );
  }

  late final _fmat_set_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<fmat_t>, smpl_t, uint_t, uint_t)>>('fmat_set_sample');
  late final _fmat_set_sample = _fmat_set_samplePtr
      .asFunction<void Function(ffi.Pointer<fmat_t>, double, int, int)>();

  /// read channel vector from a buffer
  ///
  /// \param s vector to read from
  /// \param channel channel to read from
  /// \param output ::fvec_t to output to
  void fmat_get_channel(
    ffi.Pointer<fmat_t> s,
    int channel,
    ffi.Pointer<fvec_t> output,
  ) {
    return _fmat_get_channel(
      s,
      channel,
      output,
    );
  }

  late final _fmat_get_channelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fmat_t>, uint_t,
              ffi.Pointer<fvec_t>)>>('fmat_get_channel');
  late final _fmat_get_channel = _fmat_get_channelPtr.asFunction<
      void Function(ffi.Pointer<fmat_t>, int, ffi.Pointer<fvec_t>)>();

  /// get vector buffer from an fmat data
  ///
  /// \param s vector to read from
  /// \param channel channel to read from
  ffi.Pointer<smpl_t> fmat_get_channel_data(
    ffi.Pointer<fmat_t> s,
    int channel,
  ) {
    return _fmat_get_channel_data(
      s,
      channel,
    );
  }

  late final _fmat_get_channel_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<smpl_t> Function(
              ffi.Pointer<fmat_t>, uint_t)>>('fmat_get_channel_data');
  late final _fmat_get_channel_data = _fmat_get_channel_dataPtr
      .asFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<fmat_t>, int)>();

  /// read data from a buffer
  ///
  /// \param s vector to read from
  ffi.Pointer<ffi.Pointer<smpl_t>> fmat_get_data(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_get_data(
      s,
    );
  }

  late final _fmat_get_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<smpl_t>> Function(
              ffi.Pointer<fmat_t>)>>('fmat_get_data');
  late final _fmat_get_data = _fmat_get_dataPtr.asFunction<
      ffi.Pointer<ffi.Pointer<smpl_t>> Function(ffi.Pointer<fmat_t>)>();

  /// print out fmat data
  ///
  /// \param s vector to print out
  void fmat_print(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_print(
      s,
    );
  }

  late final _fmat_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
          'fmat_print');
  late final _fmat_print =
      _fmat_printPtr.asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// set all elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void fmat_set(
    ffi.Pointer<fmat_t> s,
    double val,
  ) {
    return _fmat_set(
      s,
      val,
    );
  }

  late final _fmat_setPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>, smpl_t)>>(
      'fmat_set');
  late final _fmat_set =
      _fmat_setPtr.asFunction<void Function(ffi.Pointer<fmat_t>, double)>();

  /// set all elements to zero
  ///
  /// \param s vector to modify
  void fmat_zeros(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_zeros(
      s,
    );
  }

  late final _fmat_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
          'fmat_zeros');
  late final _fmat_zeros =
      _fmat_zerosPtr.asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// set all elements to ones
  ///
  /// \param s vector to modify
  void fmat_ones(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_ones(
      s,
    );
  }

  late final _fmat_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
          'fmat_ones');
  late final _fmat_ones =
      _fmat_onesPtr.asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// revert order of vector elements
  ///
  /// \param s vector to revert
  void fmat_rev(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_rev(
      s,
    );
  }

  late final _fmat_revPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
          'fmat_rev');
  late final _fmat_rev =
      _fmat_revPtr.asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// apply weight to vector
  ///
  /// If the weight vector is longer than s, only the first elements are used. If
  /// the weight vector is shorter than s, the last elements of s are not weighted.
  ///
  /// \param s vector to weight
  /// \param weight weighting coefficients
  void fmat_weight(
    ffi.Pointer<fmat_t> s,
    ffi.Pointer<fmat_t> weight,
  ) {
    return _fmat_weight(
      s,
      weight,
    );
  }

  late final _fmat_weightPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<fmat_t>, ffi.Pointer<fmat_t>)>>('fmat_weight');
  late final _fmat_weight = _fmat_weightPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>, ffi.Pointer<fmat_t>)>();

  /// make a copy of a matrix
  ///
  /// \param s source vector
  /// \param t vector to copy to
  void fmat_copy(
    ffi.Pointer<fmat_t> s,
    ffi.Pointer<fmat_t> t,
  ) {
    return _fmat_copy(
      s,
      t,
    );
  }

  late final _fmat_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<fmat_t>, ffi.Pointer<fmat_t>)>>('fmat_copy');
  late final _fmat_copy = _fmat_copyPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>, ffi.Pointer<fmat_t>)>();

  /// compute the product of a matrix by a vector
  ///
  /// \param s matrix to compute product with
  /// \param scale vector to compute product with
  /// \param output vector to store restults in
  void fmat_vecmul(
    ffi.Pointer<fmat_t> s,
    ffi.Pointer<fvec_t> scale,
    ffi.Pointer<fvec_t> output,
  ) {
    return _fmat_vecmul(
      s,
      scale,
      output,
    );
  }

  late final _fmat_vecmulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fmat_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('fmat_vecmul');
  late final _fmat_vecmul = _fmat_vecmulPtr.asFunction<
      void Function(
          ffi.Pointer<fmat_t>, ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>();

  /// create window
  ///
  /// \param window_type type of the window to create
  /// \param size length of the window to create (see fvec_set_window())
  ffi.Pointer<fvec_t> new_aubio_window(
    ffi.Pointer<char_t> window_type,
    int size,
  ) {
    return _new_aubio_window(
      window_type,
      size,
    );
  }

  late final _new_aubio_windowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<fvec_t> Function(
              ffi.Pointer<char_t>, uint_t)>>('new_aubio_window');
  late final _new_aubio_window = _new_aubio_windowPtr
      .asFunction<ffi.Pointer<fvec_t> Function(ffi.Pointer<char_t>, int)>();

  /// set elements of a vector to window coefficients
  ///
  /// \param window exsting ::fvec_t to use
  /// \param window_type type of the window to create
  ///
  /// List of available window types: "rectangle", "hamming", "hanning",
  /// "hanningz", "blackman", "blackman_harris", "gaussian", "welch", "parzen",
  /// "default".
  ///
  /// "default" is equivalent to "hanningz".
  ///
  /// References:
  ///
  /// - <a href="http://en.wikipedia.org/wiki/Window_function">Window
  /// function</a> on Wikipedia
  /// - Amalia de Götzen, Nicolas Bernardini, and Daniel Arfib. Traditional (?)
  /// implementations of a phase vocoder: the tricks of the trade. In Proceedings of
  /// the International Conference on Digital Audio Effects (DAFx-00), pages 37–44,
  /// Uni- versity of Verona, Italy, 2000.
  /// (<a href="http://www.cs.princeton.edu/courses/archive/spr09/cos325/Bernardini.pdf">
  /// pdf</a>)
  int fvec_set_window(
    ffi.Pointer<fvec_t> window,
    ffi.Pointer<char_t> window_type,
  ) {
    return _fvec_set_window(
      window,
      window_type,
    );
  }

  late final _fvec_set_windowPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(
              ffi.Pointer<fvec_t>, ffi.Pointer<char_t>)>>('fvec_set_window');
  late final _fvec_set_window = _fvec_set_windowPtr
      .asFunction<int Function(ffi.Pointer<fvec_t>, ffi.Pointer<char_t>)>();

  /// compute the principal argument
  ///
  /// This function maps the input phase to its corresponding value wrapped in the
  /// range \f$ [-\pi, \pi] \f$.
  ///
  /// \param phase unwrapped phase to map to the unit circle
  ///
  /// \return equivalent phase wrapped to the unit circle
  double aubio_unwrap2pi(
    double phase,
  ) {
    return _aubio_unwrap2pi(
      phase,
    );
  }

  late final _aubio_unwrap2piPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_unwrap2pi');
  late final _aubio_unwrap2pi =
      _aubio_unwrap2piPtr.asFunction<double Function(double)>();

  /// convert frequency bin to midi value
  double aubio_bintomidi(
    double bin,
    double samplerate,
    double fftsize,
  ) {
    return _aubio_bintomidi(
      bin,
      samplerate,
      fftsize,
    );
  }

  late final _aubio_bintomidiPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t, smpl_t, smpl_t)>>(
          'aubio_bintomidi');
  late final _aubio_bintomidi =
      _aubio_bintomidiPtr.asFunction<double Function(double, double, double)>();

  /// convert midi value to frequency bin
  double aubio_miditobin(
    double midi,
    double samplerate,
    double fftsize,
  ) {
    return _aubio_miditobin(
      midi,
      samplerate,
      fftsize,
    );
  }

  late final _aubio_miditobinPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t, smpl_t, smpl_t)>>(
          'aubio_miditobin');
  late final _aubio_miditobin =
      _aubio_miditobinPtr.asFunction<double Function(double, double, double)>();

  /// convert frequency bin to frequency (Hz)
  double aubio_bintofreq(
    double bin,
    double samplerate,
    double fftsize,
  ) {
    return _aubio_bintofreq(
      bin,
      samplerate,
      fftsize,
    );
  }

  late final _aubio_bintofreqPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t, smpl_t, smpl_t)>>(
          'aubio_bintofreq');
  late final _aubio_bintofreq =
      _aubio_bintofreqPtr.asFunction<double Function(double, double, double)>();

  /// convert frequency (Hz) to frequency bin
  double aubio_freqtobin(
    double freq,
    double samplerate,
    double fftsize,
  ) {
    return _aubio_freqtobin(
      freq,
      samplerate,
      fftsize,
    );
  }

  late final _aubio_freqtobinPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t, smpl_t, smpl_t)>>(
          'aubio_freqtobin');
  late final _aubio_freqtobin =
      _aubio_freqtobinPtr.asFunction<double Function(double, double, double)>();

  /// convert frequency (Hz) to mel
  ///
  /// \param freq input frequency, in Hz
  ///
  /// \return output mel
  ///
  /// Converts a scalar from the frequency domain to the mel scale using Slaney
  /// Auditory Toolbox's implementation:
  ///
  /// If \f$ f < 1000 \f$, \f$ m = 3 f / 200 \f$.
  ///
  /// If \f$ f >= 1000 \f$, \f$ m = 1000 + 27 \frac{{ln}(f) - ln(1000))}
  /// {{ln}(6400) - ln(1000)}
  /// \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_meltohz(), aubio_hztomel_htk().
  double aubio_hztomel(
    double freq,
  ) {
    return _aubio_hztomel(
      freq,
    );
  }

  late final _aubio_hztomelPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_hztomel');
  late final _aubio_hztomel =
      _aubio_hztomelPtr.asFunction<double Function(double)>();

  /// convert mel to frequency (Hz)
  ///
  /// \param mel input mel
  ///
  /// \return output frequency, in Hz
  ///
  /// Converts a scalar from the mel scale to the frequency domain using Slaney
  /// Auditory Toolbox's implementation:
  ///
  /// If \f$ f < 1000 \f$, \f$ f = 200 m/3 \f$.
  ///
  /// If \f$ f \geq 1000 \f$, \f$ f = 1000 + \left(\frac{6400}{1000}\right)
  /// ^{\frac{m - 1000}{27}} \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_hztomel(), aubio_meltohz_htk().
  ///
  /// References
  /// ----------
  ///
  /// Malcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*
  /// https://engineering.purdue.edu/~malcolm/interval/1998-010/
  double aubio_meltohz(
    double mel,
  ) {
    return _aubio_meltohz(
      mel,
    );
  }

  late final _aubio_meltohzPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_meltohz');
  late final _aubio_meltohz =
      _aubio_meltohzPtr.asFunction<double Function(double)>();

  /// convert frequency (Hz) to mel
  ///
  /// \param freq input frequency, in Hz
  ///
  /// \return output mel
  ///
  /// Converts a scalar from the frequency domain to the mel scale, using the
  /// equation defined by O'Shaughnessy, as implemented in the HTK speech
  /// recognition toolkit:
  ///
  /// \f$ m = 1127 + ln(1 + \frac{f}{700}) \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_meltohz_htk(), aubio_hztomel().
  ///
  /// References
  /// ----------
  ///
  /// Douglas O'Shaughnessy (1987). *Speech communication: human and machine*.
  /// Addison-Wesley. p. 150. ISBN 978-0-201-16520-3.
  ///
  /// HTK Speech Recognition Toolkit: http://htk.eng.cam.ac.uk/
  double aubio_hztomel_htk(
    double freq,
  ) {
    return _aubio_hztomel_htk(
      freq,
    );
  }

  late final _aubio_hztomel_htkPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_hztomel_htk');
  late final _aubio_hztomel_htk =
      _aubio_hztomel_htkPtr.asFunction<double Function(double)>();

  /// convert mel to frequency (Hz)
  ///
  /// \param mel input mel
  ///
  /// \return output frequency, in Hz
  ///
  /// Converts a scalar from the mel scale to the frequency domain, using the
  /// equation defined by O'Shaughnessy, as implemented in the HTK speech
  /// recognition toolkit:
  ///
  /// \f$ f = 700 * {e}^\left(\frac{f}{1127} - 1\right) \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_hztomel_htk(), aubio_meltohz().
  double aubio_meltohz_htk(
    double mel,
  ) {
    return _aubio_meltohz_htk(
      mel,
    );
  }

  late final _aubio_meltohz_htkPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_meltohz_htk');
  late final _aubio_meltohz_htk =
      _aubio_meltohz_htkPtr.asFunction<double Function(double)>();

  /// convert frequency (Hz) to midi value (0-128)
  double aubio_freqtomidi(
    double freq,
  ) {
    return _aubio_freqtomidi(
      freq,
    );
  }

  late final _aubio_freqtomidiPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_freqtomidi');
  late final _aubio_freqtomidi =
      _aubio_freqtomidiPtr.asFunction<double Function(double)>();

  /// convert midi value (0-128) to frequency (Hz)
  double aubio_miditofreq(
    double midi,
  ) {
    return _aubio_miditofreq(
      midi,
    );
  }

  late final _aubio_miditofreqPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_miditofreq');
  late final _aubio_miditofreq =
      _aubio_miditofreqPtr.asFunction<double Function(double)>();

  /// clean up cached memory at the end of program
  ///
  /// This function should be used at the end of programs to purge all cached
  /// memory. So far it is only useful to clean FFTW's cache.
  void aubio_cleanup() {
    return _aubio_cleanup();
  }

  late final _aubio_cleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('aubio_cleanup');
  late final _aubio_cleanup = _aubio_cleanupPtr.asFunction<void Function()>();

  /// zero-crossing rate (ZCR)
  ///
  /// The zero-crossing rate is the number of times a signal changes sign,
  /// divided by the length of this signal.
  ///
  /// \param v vector to compute ZCR from
  ///
  /// \return zero-crossing rate of v
  double aubio_zero_crossing_rate(
    ffi.Pointer<fvec_t> v,
  ) {
    return _aubio_zero_crossing_rate(
      v,
    );
  }

  late final _aubio_zero_crossing_ratePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
          'aubio_zero_crossing_rate');
  late final _aubio_zero_crossing_rate = _aubio_zero_crossing_ratePtr
      .asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// compute sound level on a linear scale
  ///
  /// This gives the average of the square amplitudes.
  ///
  /// \param v vector to compute level from
  ///
  /// \return level of v
  double aubio_level_lin(
    ffi.Pointer<fvec_t> v,
  ) {
    return _aubio_level_lin(
      v,
    );
  }

  late final _aubio_level_linPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
          'aubio_level_lin');
  late final _aubio_level_lin =
      _aubio_level_linPtr.asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// compute sound pressure level (SPL) in dB
  ///
  /// This quantity is often wrongly called 'loudness'.
  ///
  /// This gives ten times the log10 of the average of the square amplitudes.
  ///
  /// \param v vector to compute dB SPL from
  ///
  /// \return level of v in dB SPL
  double aubio_db_spl(
    ffi.Pointer<fvec_t> v,
  ) {
    return _aubio_db_spl(
      v,
    );
  }

  late final _aubio_db_splPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
          'aubio_db_spl');
  late final _aubio_db_spl =
      _aubio_db_splPtr.asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// check if buffer level in dB SPL is under a given threshold
  ///
  /// \param v vector to get level from
  /// \param threshold threshold in dB SPL
  ///
  /// \return 1 if level is under the given threshold, 0 otherwise
  int aubio_silence_detection(
    ffi.Pointer<fvec_t> v,
    double threshold,
  ) {
    return _aubio_silence_detection(
      v,
      threshold,
    );
  }

  late final _aubio_silence_detectionPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<fvec_t>, smpl_t)>>(
          'aubio_silence_detection');
  late final _aubio_silence_detection = _aubio_silence_detectionPtr
      .asFunction<int Function(ffi.Pointer<fvec_t>, double)>();

  /// get buffer level if level >= threshold, 1. otherwise
  ///
  /// \param v vector to get level from
  /// \param threshold threshold in dB SPL
  ///
  /// \return level in dB SPL if level >= threshold, 1. otherwise
  double aubio_level_detection(
    ffi.Pointer<fvec_t> v,
    double threshold,
  ) {
    return _aubio_level_detection(
      v,
      threshold,
    );
  }

  late final _aubio_level_detectionPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>, smpl_t)>>(
          'aubio_level_detection');
  late final _aubio_level_detection = _aubio_level_detectionPtr
      .asFunction<double Function(ffi.Pointer<fvec_t>, double)>();

  /// clamp the values of a vector within the range [-abs(max), abs(max)]
  ///
  /// \param in vector to clamp
  /// \param absmax maximum value over which input vector elements should be clamped
  void fvec_clamp(
    ffi.Pointer<fvec_t> in1,
    double absmax,
  ) {
    return _fvec_clamp(
      in1,
      absmax,
    );
  }

  late final _fvec_clampPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>>(
      'fvec_clamp');
  late final _fvec_clamp =
      _fvec_clampPtr.asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// compute \f$e^x\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_exp(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_exp(
      s,
    );
  }

  late final _fvec_expPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_exp');
  late final _fvec_exp =
      _fvec_expPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute \f$cos(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_cos(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_cos(
      s,
    );
  }

  late final _fvec_cosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_cos');
  late final _fvec_cos =
      _fvec_cosPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute \f$sin(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_sin(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_sin(
      s,
    );
  }

  late final _fvec_sinPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_sin');
  late final _fvec_sin =
      _fvec_sinPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$abs(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_abs(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_abs(
      s,
    );
  }

  late final _fvec_absPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_abs');
  late final _fvec_abs =
      _fvec_absPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$sqrt(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_sqrt(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_sqrt(
      s,
    );
  }

  late final _fvec_sqrtPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_sqrt');
  late final _fvec_sqrt =
      _fvec_sqrtPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$log10(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_log10(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_log10(
      s,
    );
  }

  late final _fvec_log10Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_log10');
  late final _fvec_log10 =
      _fvec_log10Ptr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$log(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_log(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_log(
      s,
    );
  }

  late final _fvec_logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_log');
  late final _fvec_log =
      _fvec_logPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$floor(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_floor(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_floor(
      s,
    );
  }

  late final _fvec_floorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_floor');
  late final _fvec_floor =
      _fvec_floorPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$ceil(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_ceil(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_ceil(
      s,
    );
  }

  late final _fvec_ceilPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_ceil');
  late final _fvec_ceil =
      _fvec_ceilPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$round(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_round(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_round(
      s,
    );
  }

  late final _fvec_roundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_round');
  late final _fvec_round =
      _fvec_roundPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// raise each vector elements to the power pow
  ///
  /// \param s vector to modify
  /// \param pow power to raise to
  void fvec_pow(
    ffi.Pointer<fvec_t> s,
    double pow,
  ) {
    return _fvec_pow(
      s,
      pow,
    );
  }

  late final _fvec_powPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>>(
      'fvec_pow');
  late final _fvec_pow =
      _fvec_powPtr.asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// create resampler object
  ///
  /// \param ratio output_sample_rate / input_sample_rate
  /// \param type libsamplerate resampling type, see http://www.mega-nerd.com/SRC/api_misc.html#Converters
  ffi.Pointer<aubio_resampler_t> new_aubio_resampler(
    double ratio,
    int type,
  ) {
    return _new_aubio_resampler(
      ratio,
      type,
    );
  }

  late final _new_aubio_resamplerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_resampler_t> Function(
              smpl_t, uint_t)>>('new_aubio_resampler');
  late final _new_aubio_resampler = _new_aubio_resamplerPtr
      .asFunction<ffi.Pointer<aubio_resampler_t> Function(double, int)>();

  /// delete resampler object
  void del_aubio_resampler(
    ffi.Pointer<aubio_resampler_t> s,
  ) {
    return _del_aubio_resampler(
      s,
    );
  }

  late final _del_aubio_resamplerPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_resampler_t>)>>(
      'del_aubio_resampler');
  late final _del_aubio_resampler = _del_aubio_resamplerPtr
      .asFunction<void Function(ffi.Pointer<aubio_resampler_t>)>();

  /// resample input in output
  ///
  /// \param s resampler object
  /// \param input input buffer of size N
  /// \param output output buffer of size N*ratio
  void aubio_resampler_do(
    ffi.Pointer<aubio_resampler_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_resampler_do(
      s,
      input,
      output,
    );
  }

  late final _aubio_resampler_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_resampler_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_resampler_do');
  late final _aubio_resampler_do = _aubio_resampler_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_resampler_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// filter input vector (in-place)
  ///
  /// \param f filter object as returned by new_aubio_filter()
  /// \param in input vector to filter
  void aubio_filter_do(
    ffi.Pointer<aubio_filter_t> f,
    ffi.Pointer<fvec_t> in1,
  ) {
    return _aubio_filter_do(
      f,
      in1,
    );
  }

  late final _aubio_filter_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_filter_t>,
              ffi.Pointer<fvec_t>)>>('aubio_filter_do');
  late final _aubio_filter_do = _aubio_filter_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_filter_t>, ffi.Pointer<fvec_t>)>();

  /// filter input vector (out-of-place)
  ///
  /// \param f filter object as returned by new_aubio_filter()
  /// \param in input vector to filter
  /// \param out output vector to store filtered input
  void aubio_filter_do_outplace(
    ffi.Pointer<aubio_filter_t> f,
    ffi.Pointer<fvec_t> in1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_filter_do_outplace(
      f,
      in1,
      out,
    );
  }

  late final _aubio_filter_do_outplacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_filter_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_filter_do_outplace');
  late final _aubio_filter_do_outplace =
      _aubio_filter_do_outplacePtr.asFunction<
          void Function(ffi.Pointer<aubio_filter_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>();

  /// filter input vector forward and backward
  ///
  /// \param f ::aubio_filter_t object as returned by new_aubio_filter()
  /// \param in ::fvec_t input vector to filter
  /// \param tmp memory space to use for computation
  void aubio_filter_do_filtfilt(
    ffi.Pointer<aubio_filter_t> f,
    ffi.Pointer<fvec_t> in1,
    ffi.Pointer<fvec_t> tmp,
  ) {
    return _aubio_filter_do_filtfilt(
      f,
      in1,
      tmp,
    );
  }

  late final _aubio_filter_do_filtfiltPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_filter_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_filter_do_filtfilt');
  late final _aubio_filter_do_filtfilt =
      _aubio_filter_do_filtfiltPtr.asFunction<
          void Function(ffi.Pointer<aubio_filter_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>();

  /// returns a pointer to feedback coefficients \f$ a_i \f$
  ///
  /// \param f filter object to get parameters from
  ///
  /// \return a pointer to the \f$ a_0 ... a_i ... a_P \f$ coefficients
  ffi.Pointer<lvec_t> aubio_filter_get_feedback(
    ffi.Pointer<aubio_filter_t> f,
  ) {
    return _aubio_filter_get_feedback(
      f,
    );
  }

  late final _aubio_filter_get_feedbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lvec_t> Function(
              ffi.Pointer<aubio_filter_t>)>>('aubio_filter_get_feedback');
  late final _aubio_filter_get_feedback = _aubio_filter_get_feedbackPtr
      .asFunction<ffi.Pointer<lvec_t> Function(ffi.Pointer<aubio_filter_t>)>();

  /// returns a pointer to feedforward coefficients \f$ b_i \f$
  ///
  /// \param f filter object to get coefficients from
  ///
  /// \return a pointer to the \f$ b_0 ... b_i ... b_P \f$ coefficients
  ffi.Pointer<lvec_t> aubio_filter_get_feedforward(
    ffi.Pointer<aubio_filter_t> f,
  ) {
    return _aubio_filter_get_feedforward(
      f,
    );
  }

  late final _aubio_filter_get_feedforwardPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lvec_t> Function(
              ffi.Pointer<aubio_filter_t>)>>('aubio_filter_get_feedforward');
  late final _aubio_filter_get_feedforward = _aubio_filter_get_feedforwardPtr
      .asFunction<ffi.Pointer<lvec_t> Function(ffi.Pointer<aubio_filter_t>)>();

  /// get order of the filter
  ///
  /// \param f filter to get order from
  ///
  /// \return the order of the filter
  int aubio_filter_get_order(
    ffi.Pointer<aubio_filter_t> f,
  ) {
    return _aubio_filter_get_order(
      f,
    );
  }

  late final _aubio_filter_get_orderPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_filter_t>)>>(
          'aubio_filter_get_order');
  late final _aubio_filter_get_order = _aubio_filter_get_orderPtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>)>();

  /// get sampling rate of the filter
  ///
  /// \param f filter to get sampling rate from
  ///
  /// \return the sampling rate of the filter, in Hz
  int aubio_filter_get_samplerate(
    ffi.Pointer<aubio_filter_t> f,
  ) {
    return _aubio_filter_get_samplerate(
      f,
    );
  }

  late final _aubio_filter_get_sampleratePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_filter_t>)>>(
          'aubio_filter_get_samplerate');
  late final _aubio_filter_get_samplerate = _aubio_filter_get_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>)>();

  /// get sampling rate of the filter
  ///
  /// \param f filter to get sampling rate from
  /// \param samplerate sample rate to set the filter to
  ///
  /// \return the sampling rate of the filter, in Hz
  int aubio_filter_set_samplerate(
    ffi.Pointer<aubio_filter_t> f,
    int samplerate,
  ) {
    return _aubio_filter_set_samplerate(
      f,
      samplerate,
    );
  }

  late final _aubio_filter_set_sampleratePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filter_t>,
              uint_t)>>('aubio_filter_set_samplerate');
  late final _aubio_filter_set_samplerate = _aubio_filter_set_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>, int)>();

  /// reset filter memory
  ///
  /// \param f filter object as returned by new_aubio_filter()
  void aubio_filter_do_reset(
    ffi.Pointer<aubio_filter_t> f,
  ) {
    return _aubio_filter_do_reset(
      f,
    );
  }

  late final _aubio_filter_do_resetPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_filter_t>)>>(
      'aubio_filter_do_reset');
  late final _aubio_filter_do_reset = _aubio_filter_do_resetPtr
      .asFunction<void Function(ffi.Pointer<aubio_filter_t>)>();

  /// create new filter object
  ///
  /// This function creates a new ::aubio_filter_t object, given the order of the
  /// filter.
  ///
  /// \param order order of the filter (number of coefficients)
  ///
  /// \return the newly created filter object
  ffi.Pointer<aubio_filter_t> new_aubio_filter(
    int order,
  ) {
    return _new_aubio_filter(
      order,
    );
  }

  late final _new_aubio_filterPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_filter_t> Function(uint_t)>>(
          'new_aubio_filter');
  late final _new_aubio_filter = _new_aubio_filterPtr
      .asFunction<ffi.Pointer<aubio_filter_t> Function(int)>();

  /// delete a filter object
  ///
  /// \param f filter object to delete
  void del_aubio_filter(
    ffi.Pointer<aubio_filter_t> f,
  ) {
    return _del_aubio_filter(
      f,
    );
  }

  late final _del_aubio_filterPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_filter_t>)>>(
      'del_aubio_filter');
  late final _del_aubio_filter = _del_aubio_filterPtr
      .asFunction<void Function(ffi.Pointer<aubio_filter_t>)>();

  /// set coefficients of a biquad filter
  ///
  /// \param f filter object as returned by new_aubio_filter()
  /// \param b0 forward filter coefficient
  /// \param b1 forward filter coefficient
  /// \param b2 forward filter coefficient
  /// \param a1 feedback filter coefficient
  /// \param a2 feedback filter coefficient
  int aubio_filter_set_biquad(
    ffi.Pointer<aubio_filter_t> f,
    double b0,
    double b1,
    double b2,
    double a1,
    double a2,
  ) {
    return _aubio_filter_set_biquad(
      f,
      b0,
      b1,
      b2,
      a1,
      a2,
    );
  }

  late final _aubio_filter_set_biquadPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filter_t>, lsmp_t, lsmp_t, lsmp_t,
              lsmp_t, lsmp_t)>>('aubio_filter_set_biquad');
  late final _aubio_filter_set_biquad = _aubio_filter_set_biquadPtr.asFunction<
      int Function(ffi.Pointer<aubio_filter_t>, double, double, double, double,
          double)>();

  /// create biquad filter with `b0`, `b1`, `b2`, `a1`, `a2` coeffs
  ///
  /// \param b0 forward filter coefficient
  /// \param b1 forward filter coefficient
  /// \param b2 forward filter coefficient
  /// \param a1 feedback filter coefficient
  /// \param a2 feedback filter coefficient
  ffi.Pointer<aubio_filter_t> new_aubio_filter_biquad(
    double b0,
    double b1,
    double b2,
    double a1,
    double a2,
  ) {
    return _new_aubio_filter_biquad(
      b0,
      b1,
      b2,
      a1,
      a2,
    );
  }

  late final _new_aubio_filter_biquadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_filter_t> Function(lsmp_t, lsmp_t, lsmp_t, lsmp_t,
              lsmp_t)>>('new_aubio_filter_biquad');
  late final _new_aubio_filter_biquad = _new_aubio_filter_biquadPtr.asFunction<
      ffi.Pointer<aubio_filter_t> Function(
          double, double, double, double, double)>();

  /// create new A-design filter
  ///
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  ///
  /// \return a new filter object
  ffi.Pointer<aubio_filter_t> new_aubio_filter_a_weighting(
    int samplerate,
  ) {
    return _new_aubio_filter_a_weighting(
      samplerate,
    );
  }

  late final _new_aubio_filter_a_weightingPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_filter_t> Function(uint_t)>>(
          'new_aubio_filter_a_weighting');
  late final _new_aubio_filter_a_weighting = _new_aubio_filter_a_weightingPtr
      .asFunction<ffi.Pointer<aubio_filter_t> Function(int)>();

  /// set feedback and feedforward coefficients of a A-weighting filter
  ///
  /// \param f filter object to get coefficients from
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  int aubio_filter_set_a_weighting(
    ffi.Pointer<aubio_filter_t> f,
    int samplerate,
  ) {
    return _aubio_filter_set_a_weighting(
      f,
      samplerate,
    );
  }

  late final _aubio_filter_set_a_weightingPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filter_t>,
              uint_t)>>('aubio_filter_set_a_weighting');
  late final _aubio_filter_set_a_weighting = _aubio_filter_set_a_weightingPtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>, int)>();

  /// create new C-design filter
  ///
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  ///
  /// \return a new filter object
  ffi.Pointer<aubio_filter_t> new_aubio_filter_c_weighting(
    int samplerate,
  ) {
    return _new_aubio_filter_c_weighting(
      samplerate,
    );
  }

  late final _new_aubio_filter_c_weightingPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_filter_t> Function(uint_t)>>(
          'new_aubio_filter_c_weighting');
  late final _new_aubio_filter_c_weighting = _new_aubio_filter_c_weightingPtr
      .asFunction<ffi.Pointer<aubio_filter_t> Function(int)>();

  /// set feedback and feedforward coefficients of a C-weighting filter
  ///
  /// \param f filter object to get coefficients from
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  int aubio_filter_set_c_weighting(
    ffi.Pointer<aubio_filter_t> f,
    int samplerate,
  ) {
    return _aubio_filter_set_c_weighting(
      f,
      samplerate,
    );
  }

  late final _aubio_filter_set_c_weightingPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filter_t>,
              uint_t)>>('aubio_filter_set_c_weighting');
  late final _aubio_filter_set_c_weighting = _aubio_filter_set_c_weightingPtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>, int)>();

  /// create new FFT computation object
  ///
  /// \param size length of the FFT
  ffi.Pointer<aubio_fft_t> new_aubio_fft(
    int size,
  ) {
    return _new_aubio_fft(
      size,
    );
  }

  late final _new_aubio_fftPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_fft_t> Function(uint_t)>>(
          'new_aubio_fft');
  late final _new_aubio_fft =
      _new_aubio_fftPtr.asFunction<ffi.Pointer<aubio_fft_t> Function(int)>();

  /// delete FFT object
  ///
  /// \param s fft object as returned by new_aubio_fft
  void del_aubio_fft(
    ffi.Pointer<aubio_fft_t> s,
  ) {
    return _del_aubio_fft(
      s,
    );
  }

  late final _del_aubio_fftPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_fft_t>)>>(
          'del_aubio_fft');
  late final _del_aubio_fft =
      _del_aubio_fftPtr.asFunction<void Function(ffi.Pointer<aubio_fft_t>)>();

  /// compute forward FFT
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param input input signal
  /// \param spectrum output spectrum
  void aubio_fft_do(
    ffi.Pointer<aubio_fft_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_do(
      s,
      input,
      spectrum,
    );
  }

  late final _aubio_fft_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_fft_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<cvec_t>)>>('aubio_fft_do');
  late final _aubio_fft_do = _aubio_fft_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_fft_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<cvec_t>)>();

  /// compute backward (inverse) FFT
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param spectrum input spectrum
  /// \param output output signal
  void aubio_fft_rdo(
    ffi.Pointer<aubio_fft_t> s,
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_fft_rdo(
      s,
      spectrum,
      output,
    );
  }

  late final _aubio_fft_rdoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_fft_t>, ffi.Pointer<cvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_fft_rdo');
  late final _aubio_fft_rdo = _aubio_fft_rdoPtr.asFunction<
      void Function(ffi.Pointer<aubio_fft_t>, ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// compute forward FFT
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param input real input signal
  /// \param compspec complex output fft real/imag
  void aubio_fft_do_complex(
    ffi.Pointer<aubio_fft_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_do_complex(
      s,
      input,
      compspec,
    );
  }

  late final _aubio_fft_do_complexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_fft_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_fft_do_complex');
  late final _aubio_fft_do_complex = _aubio_fft_do_complexPtr.asFunction<
      void Function(ffi.Pointer<aubio_fft_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// compute backward (inverse) FFT from real/imag
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param compspec real/imag input fft array
  /// \param output real output array
  void aubio_fft_rdo_complex(
    ffi.Pointer<aubio_fft_t> s,
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_fft_rdo_complex(
      s,
      compspec,
      output,
    );
  }

  late final _aubio_fft_rdo_complexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_fft_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_fft_rdo_complex');
  late final _aubio_fft_rdo_complex = _aubio_fft_rdo_complexPtr.asFunction<
      void Function(ffi.Pointer<aubio_fft_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// convert real/imag spectrum to norm/phas spectrum
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_spectrum(
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_get_spectrum(
      compspec,
      spectrum,
    );
  }

  late final _aubio_fft_get_spectrumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fvec_t>,
              ffi.Pointer<cvec_t>)>>('aubio_fft_get_spectrum');
  late final _aubio_fft_get_spectrum = _aubio_fft_get_spectrumPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)>();

  /// convert real/imag spectrum to norm/phas spectrum
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_realimag(
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_get_realimag(
      spectrum,
      compspec,
    );
  }

  late final _aubio_fft_get_realimagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<cvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_fft_get_realimag');
  late final _aubio_fft_get_realimag = _aubio_fft_get_realimagPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)>();

  /// compute phas spectrum from real/imag parts
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_phas(
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_get_phas(
      compspec,
      spectrum,
    );
  }

  late final _aubio_fft_get_phasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)>>('aubio_fft_get_phas');
  late final _aubio_fft_get_phas = _aubio_fft_get_phasPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)>();

  /// compute imaginary part from the norm/phas cvec
  ///
  /// \param spectrum norm/phas input array
  /// \param compspec real/imag output fft array
  void aubio_fft_get_imag(
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_get_imag(
      spectrum,
      compspec,
    );
  }

  late final _aubio_fft_get_imagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)>>('aubio_fft_get_imag');
  late final _aubio_fft_get_imag = _aubio_fft_get_imagPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)>();

  /// compute norm component from real/imag parts
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_norm(
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_get_norm(
      compspec,
      spectrum,
    );
  }

  late final _aubio_fft_get_normPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)>>('aubio_fft_get_norm');
  late final _aubio_fft_get_norm = _aubio_fft_get_normPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)>();

  /// compute real part from norm/phas components
  ///
  /// \param spectrum norm/phas input array
  /// \param compspec real/imag output fft array
  void aubio_fft_get_real(
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_get_real(
      spectrum,
      compspec,
    );
  }

  late final _aubio_fft_get_realPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)>>('aubio_fft_get_real');
  late final _aubio_fft_get_real = _aubio_fft_get_realPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)>();

  /// create new DCT computation object
  ///
  /// \param size length of the DCT
  ffi.Pointer<aubio_dct_t> new_aubio_dct(
    int size,
  ) {
    return _new_aubio_dct(
      size,
    );
  }

  late final _new_aubio_dctPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_dct_t> Function(uint_t)>>(
          'new_aubio_dct');
  late final _new_aubio_dct =
      _new_aubio_dctPtr.asFunction<ffi.Pointer<aubio_dct_t> Function(int)>();

  /// compute forward DCT
  ///
  /// \param s dct object as returned by new_aubio_dct
  /// \param input input signal
  /// \param dct_output transformed input array
  void aubio_dct_do(
    ffi.Pointer<aubio_dct_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> dct_output,
  ) {
    return _aubio_dct_do(
      s,
      input,
      dct_output,
    );
  }

  late final _aubio_dct_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_dct_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_dct_do');
  late final _aubio_dct_do = _aubio_dct_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_dct_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// compute backward DCT
  ///
  /// \param s dct object as returned by new_aubio_dct
  /// \param input input signal
  /// \param idct_output transformed input array
  void aubio_dct_rdo(
    ffi.Pointer<aubio_dct_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> idct_output,
  ) {
    return _aubio_dct_rdo(
      s,
      input,
      idct_output,
    );
  }

  late final _aubio_dct_rdoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_dct_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_dct_rdo');
  late final _aubio_dct_rdo = _aubio_dct_rdoPtr.asFunction<
      void Function(ffi.Pointer<aubio_dct_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// delete DCT object
  ///
  /// \param s dct object as returned by new_aubio_dct
  void del_aubio_dct(
    ffi.Pointer<aubio_dct_t> s,
  ) {
    return _del_aubio_dct(
      s,
    );
  }

  late final _del_aubio_dctPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_dct_t>)>>(
          'del_aubio_dct');
  late final _del_aubio_dct =
      _del_aubio_dctPtr.asFunction<void Function(ffi.Pointer<aubio_dct_t>)>();

  /// create phase vocoder object
  ///
  /// \param win_s size of analysis buffer (and length the FFT transform)
  /// \param hop_s step size between two consecutive analysis
  ffi.Pointer<aubio_pvoc_t> new_aubio_pvoc(
    int win_s,
    int hop_s,
  ) {
    return _new_aubio_pvoc(
      win_s,
      hop_s,
    );
  }

  late final _new_aubio_pvocPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<aubio_pvoc_t> Function(uint_t, uint_t)>>(
      'new_aubio_pvoc');
  late final _new_aubio_pvoc = _new_aubio_pvocPtr
      .asFunction<ffi.Pointer<aubio_pvoc_t> Function(int, int)>();

  /// delete phase vocoder object
  ///
  /// \param pv phase vocoder object as returned by new_aubio_pvoc
  void del_aubio_pvoc(
    ffi.Pointer<aubio_pvoc_t> pv,
  ) {
    return _del_aubio_pvoc(
      pv,
    );
  }

  late final _del_aubio_pvocPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_pvoc_t>)>>(
          'del_aubio_pvoc');
  late final _del_aubio_pvoc =
      _del_aubio_pvocPtr.asFunction<void Function(ffi.Pointer<aubio_pvoc_t>)>();

  /// compute spectral frame
  ///
  /// This function accepts an input vector of size [hop_s]. The
  /// analysis buffer is rotated and filled with the new data. After windowing of
  /// this signal window, the Fourier transform is computed and returned in
  /// fftgrain as two vectors, magnitude and phase.
  ///
  /// \param pv phase vocoder object as returned by new_aubio_pvoc
  /// \param in new input signal (hop_s long)
  /// \param fftgrain output spectral frame
  void aubio_pvoc_do(
    ffi.Pointer<aubio_pvoc_t> pv,
    ffi.Pointer<fvec_t> in1,
    ffi.Pointer<cvec_t> fftgrain,
  ) {
    return _aubio_pvoc_do(
      pv,
      in1,
      fftgrain,
    );
  }

  late final _aubio_pvoc_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_pvoc_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<cvec_t>)>>('aubio_pvoc_do');
  late final _aubio_pvoc_do = _aubio_pvoc_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pvoc_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<cvec_t>)>();

  /// compute signal from spectral frame
  ///
  /// This function takes an input spectral frame fftgrain of size
  /// [buf_s] and computes its inverse Fourier transform. Overlap-add
  /// synthesis is then computed using the previously synthetised frames, and the
  /// output stored in out.
  ///
  /// \param pv phase vocoder object as returned by new_aubio_pvoc
  /// \param fftgrain input spectral frame
  /// \param out output signal (hop_s long)
  void aubio_pvoc_rdo(
    ffi.Pointer<aubio_pvoc_t> pv,
    ffi.Pointer<cvec_t> fftgrain,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_pvoc_rdo(
      pv,
      fftgrain,
      out,
    );
  }

  late final _aubio_pvoc_rdoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_pvoc_t>, ffi.Pointer<cvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pvoc_rdo');
  late final _aubio_pvoc_rdo = _aubio_pvoc_rdoPtr.asFunction<
      void Function(ffi.Pointer<aubio_pvoc_t>, ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// get window size
  ///
  /// \param pv phase vocoder to get the window size from
  int aubio_pvoc_get_win(
    ffi.Pointer<aubio_pvoc_t> pv,
  ) {
    return _aubio_pvoc_get_win(
      pv,
    );
  }

  late final _aubio_pvoc_get_winPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_pvoc_t>)>>(
          'aubio_pvoc_get_win');
  late final _aubio_pvoc_get_win = _aubio_pvoc_get_winPtr
      .asFunction<int Function(ffi.Pointer<aubio_pvoc_t>)>();

  /// get hop size
  ///
  /// \param pv phase vocoder to get the hop size from
  int aubio_pvoc_get_hop(
    ffi.Pointer<aubio_pvoc_t> pv,
  ) {
    return _aubio_pvoc_get_hop(
      pv,
    );
  }

  late final _aubio_pvoc_get_hopPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_pvoc_t>)>>(
          'aubio_pvoc_get_hop');
  late final _aubio_pvoc_get_hop = _aubio_pvoc_get_hopPtr
      .asFunction<int Function(ffi.Pointer<aubio_pvoc_t>)>();

  /// set window type
  ///
  /// \param pv phase vocoder to set the window type
  /// \param window_type a string representing a window
  ///
  /// \return 0 if successful, non-zero otherwise
  int aubio_pvoc_set_window(
    ffi.Pointer<aubio_pvoc_t> pv,
    ffi.Pointer<char_t> window_type,
  ) {
    return _aubio_pvoc_set_window(
      pv,
      window_type,
    );
  }

  late final _aubio_pvoc_set_windowPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pvoc_t>,
              ffi.Pointer<char_t>)>>('aubio_pvoc_set_window');
  late final _aubio_pvoc_set_window = _aubio_pvoc_set_windowPtr.asFunction<
      int Function(ffi.Pointer<aubio_pvoc_t>, ffi.Pointer<char_t>)>();

  /// create filterbank object
  ///
  /// \param n_filters number of filters to create
  /// \param win_s size of analysis buffer (and length the FFT transform)
  ffi.Pointer<aubio_filterbank_t> new_aubio_filterbank(
    int n_filters,
    int win_s,
  ) {
    return _new_aubio_filterbank(
      n_filters,
      win_s,
    );
  }

  late final _new_aubio_filterbankPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_filterbank_t> Function(
              uint_t, uint_t)>>('new_aubio_filterbank');
  late final _new_aubio_filterbank = _new_aubio_filterbankPtr
      .asFunction<ffi.Pointer<aubio_filterbank_t> Function(int, int)>();

  /// destroy filterbank object
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  void del_aubio_filterbank(
    ffi.Pointer<aubio_filterbank_t> f,
  ) {
    return _del_aubio_filterbank(
      f,
    );
  }

  late final _del_aubio_filterbankPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_filterbank_t>)>>(
      'del_aubio_filterbank');
  late final _del_aubio_filterbank = _del_aubio_filterbankPtr
      .asFunction<void Function(ffi.Pointer<aubio_filterbank_t>)>();

  /// compute filterbank
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param in input spectrum containing an input spectrum of length `win_s`
  /// \param out output vector containing the energy found in each band, `nfilt` output values
  void aubio_filterbank_do(
    ffi.Pointer<aubio_filterbank_t> f,
    ffi.Pointer<cvec_t> in1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_filterbank_do(
      f,
      in1,
      out,
    );
  }

  late final _aubio_filterbank_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_filterbank_t>,
              ffi.Pointer<cvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_filterbank_do');
  late final _aubio_filterbank_do = _aubio_filterbank_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_filterbank_t>, ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// return a pointer to the matrix object containing all filter coefficients
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  ffi.Pointer<fmat_t> aubio_filterbank_get_coeffs(
    ffi.Pointer<aubio_filterbank_t> f,
  ) {
    return _aubio_filterbank_get_coeffs(
      f,
    );
  }

  late final _aubio_filterbank_get_coeffsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<fmat_t> Function(
              ffi.Pointer<aubio_filterbank_t>)>>('aubio_filterbank_get_coeffs');
  late final _aubio_filterbank_get_coeffs =
      _aubio_filterbank_get_coeffsPtr.asFunction<
          ffi.Pointer<fmat_t> Function(ffi.Pointer<aubio_filterbank_t>)>();

  /// copy filter coefficients to the filterbank
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param filters filter bank coefficients to copy from
  int aubio_filterbank_set_coeffs(
    ffi.Pointer<aubio_filterbank_t> f,
    ffi.Pointer<fmat_t> filters,
  ) {
    return _aubio_filterbank_set_coeffs(
      f,
      filters,
    );
  }

  late final _aubio_filterbank_set_coeffsPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>,
              ffi.Pointer<fmat_t>)>>('aubio_filterbank_set_coeffs');
  late final _aubio_filterbank_set_coeffs =
      _aubio_filterbank_set_coeffsPtr.asFunction<
          int Function(ffi.Pointer<aubio_filterbank_t>, ffi.Pointer<fmat_t>)>();

  /// set norm parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param norm `1` to norm the filters, `0` otherwise.
  ///
  /// If set to `0`, the filters will not be normalized. If set to `1`,
  /// each filter will be normalized to one. Defaults to `1`.
  ///
  /// This function should be called *before* setting the filters with one of
  /// aubio_filterbank_set_triangle_bands(), aubio_filterbank_set_mel_coeffs(),
  /// aubio_filterbank_set_mel_coeffs_htk(), or
  /// aubio_filterbank_set_mel_coeffs_slaney().
  int aubio_filterbank_set_norm(
    ffi.Pointer<aubio_filterbank_t> f,
    double norm,
  ) {
    return _aubio_filterbank_set_norm(
      f,
      norm,
    );
  }

  late final _aubio_filterbank_set_normPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>,
              smpl_t)>>('aubio_filterbank_set_norm');
  late final _aubio_filterbank_set_norm = _aubio_filterbank_set_normPtr
      .asFunction<int Function(ffi.Pointer<aubio_filterbank_t>, double)>();

  /// get norm parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \returns `1` if norm is set, `0` otherwise. Defaults to `1`.
  double aubio_filterbank_get_norm(
    ffi.Pointer<aubio_filterbank_t> f,
  ) {
    return _aubio_filterbank_get_norm(
      f,
    );
  }

  late final _aubio_filterbank_get_normPtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_filterbank_t>)>>(
      'aubio_filterbank_get_norm');
  late final _aubio_filterbank_get_norm = _aubio_filterbank_get_normPtr
      .asFunction<double Function(ffi.Pointer<aubio_filterbank_t>)>();

  /// set power parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param power Raise norm of the input spectrum norm to this power before
  /// computing filterbank.  Defaults to `1`.
  int aubio_filterbank_set_power(
    ffi.Pointer<aubio_filterbank_t> f,
    double power,
  ) {
    return _aubio_filterbank_set_power(
      f,
      power,
    );
  }

  late final _aubio_filterbank_set_powerPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>,
              smpl_t)>>('aubio_filterbank_set_power');
  late final _aubio_filterbank_set_power = _aubio_filterbank_set_powerPtr
      .asFunction<int Function(ffi.Pointer<aubio_filterbank_t>, double)>();

  /// get power parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \return current power parameter. Defaults to `1`.
  double aubio_filterbank_get_power(
    ffi.Pointer<aubio_filterbank_t> f,
  ) {
    return _aubio_filterbank_get_power(
      f,
    );
  }

  late final _aubio_filterbank_get_powerPtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_filterbank_t>)>>(
      'aubio_filterbank_get_power');
  late final _aubio_filterbank_get_power = _aubio_filterbank_get_powerPtr
      .asFunction<double Function(ffi.Pointer<aubio_filterbank_t>)>();

  /// filterbank initialization with triangular and overlapping bands
  ///
  /// \param fb filterbank object
  /// \param freqs arbitrary array of boundary frequencies
  /// \param samplerate audio sampling rate
  ///
  /// This function computes the coefficients of the filterbank based on the
  /// boundaries found in freqs, in Hz, and using triangular overlapping bands.
  int aubio_filterbank_set_triangle_bands(
    ffi.Pointer<aubio_filterbank_t> fb,
    ffi.Pointer<fvec_t> freqs,
    double samplerate,
  ) {
    return _aubio_filterbank_set_triangle_bands(
      fb,
      freqs,
      samplerate,
    );
  }

  late final _aubio_filterbank_set_triangle_bandsPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>, ffi.Pointer<fvec_t>,
              smpl_t)>>('aubio_filterbank_set_triangle_bands');
  late final _aubio_filterbank_set_triangle_bands =
      _aubio_filterbank_set_triangle_bandsPtr.asFunction<
          int Function(
              ffi.Pointer<aubio_filterbank_t>, ffi.Pointer<fvec_t>, double)>();

  /// filterbank initialization for Mel filters using Slaney's coefficients
  ///
  /// \param fb filterbank object
  /// \param samplerate audio sampling rate, in Hz
  ///
  /// The filter coefficients are built to match exactly Malcolm Slaney's Auditory
  /// Toolbox implementation (see file mfcc.m). The number of filters should be 40.
  ///
  /// References
  /// ----------
  ///
  /// Malcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*
  /// https://engineering.purdue.edu/~malcolm/interval/1998-010/
  int aubio_filterbank_set_mel_coeffs_slaney(
    ffi.Pointer<aubio_filterbank_t> fb,
    double samplerate,
  ) {
    return _aubio_filterbank_set_mel_coeffs_slaney(
      fb,
      samplerate,
    );
  }

  late final _aubio_filterbank_set_mel_coeffs_slaneyPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>,
              smpl_t)>>('aubio_filterbank_set_mel_coeffs_slaney');
  late final _aubio_filterbank_set_mel_coeffs_slaney =
      _aubio_filterbank_set_mel_coeffs_slaneyPtr
          .asFunction<int Function(ffi.Pointer<aubio_filterbank_t>, double)>();

  /// Mel filterbank initialization
  ///
  /// \param fb filterbank object
  /// \param samplerate audio sampling rate
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The filterbank will be initialized with bands linearly spaced in the mel
  /// scale, from `fmin` to `fmax`.
  ///
  /// References
  /// ----------
  ///
  /// Malcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*
  /// https://engineering.purdue.edu/~malcolm/interval/1998-010/
  int aubio_filterbank_set_mel_coeffs(
    ffi.Pointer<aubio_filterbank_t> fb,
    double samplerate,
    double fmin,
    double fmax,
  ) {
    return _aubio_filterbank_set_mel_coeffs(
      fb,
      samplerate,
      fmin,
      fmax,
    );
  }

  late final _aubio_filterbank_set_mel_coeffsPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>, smpl_t, smpl_t,
              smpl_t)>>('aubio_filterbank_set_mel_coeffs');
  late final _aubio_filterbank_set_mel_coeffs =
      _aubio_filterbank_set_mel_coeffsPtr.asFunction<
          int Function(
              ffi.Pointer<aubio_filterbank_t>, double, double, double)>();

  /// Mel filterbank initialization
  ///
  /// \param fb filterbank object
  /// \param samplerate audio sampling rate
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The bank of filters will be initalized to to cover linearly spaced bands in
  /// the Htk mel scale, from `fmin` to `fmax`.
  ///
  /// References
  /// ----------
  ///
  /// Douglas O'Shaughnessy (1987). *Speech communication: human and machine*.
  /// Addison-Wesley. p. 150. ISBN 978-0-201-16520-3.
  ///
  /// HTK Speech Recognition Toolkit: http://htk.eng.cam.ac.uk/
  int aubio_filterbank_set_mel_coeffs_htk(
    ffi.Pointer<aubio_filterbank_t> fb,
    double samplerate,
    double fmin,
    double fmax,
  ) {
    return _aubio_filterbank_set_mel_coeffs_htk(
      fb,
      samplerate,
      fmin,
      fmax,
    );
  }

  late final _aubio_filterbank_set_mel_coeffs_htkPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>, smpl_t, smpl_t,
              smpl_t)>>('aubio_filterbank_set_mel_coeffs_htk');
  late final _aubio_filterbank_set_mel_coeffs_htk =
      _aubio_filterbank_set_mel_coeffs_htkPtr.asFunction<
          int Function(
              ffi.Pointer<aubio_filterbank_t>, double, double, double)>();

  /// create mfcc object
  ///
  /// \param buf_size size of analysis buffer (and length the FFT transform)
  /// \param samplerate audio sampling rate
  /// \param n_coeffs number of desired coefficients
  /// \param n_filters number of desired filters
  ffi.Pointer<aubio_mfcc_t> new_aubio_mfcc(
    int buf_size,
    int n_filters,
    int n_coeffs,
    int samplerate,
  ) {
    return _new_aubio_mfcc(
      buf_size,
      n_filters,
      n_coeffs,
      samplerate,
    );
  }

  late final _new_aubio_mfccPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_mfcc_t> Function(
              uint_t, uint_t, uint_t, uint_t)>>('new_aubio_mfcc');
  late final _new_aubio_mfcc = _new_aubio_mfccPtr
      .asFunction<ffi.Pointer<aubio_mfcc_t> Function(int, int, int, int)>();

  /// delete mfcc object
  ///
  /// \param mf mfcc object as returned by new_aubio_mfcc
  void del_aubio_mfcc(
    ffi.Pointer<aubio_mfcc_t> mf,
  ) {
    return _del_aubio_mfcc(
      mf,
    );
  }

  late final _del_aubio_mfccPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_mfcc_t>)>>(
          'del_aubio_mfcc');
  late final _del_aubio_mfcc =
      _del_aubio_mfccPtr.asFunction<void Function(ffi.Pointer<aubio_mfcc_t>)>();

  /// mfcc object processing
  ///
  /// \param mf mfcc object as returned by new_aubio_mfcc
  /// \param in input spectrum (buf_size long)
  /// \param out output mel coefficients buffer (n_coeffs long)
  void aubio_mfcc_do(
    ffi.Pointer<aubio_mfcc_t> mf,
    ffi.Pointer<cvec_t> in1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_mfcc_do(
      mf,
      in1,
      out,
    );
  }

  late final _aubio_mfcc_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_mfcc_t>, ffi.Pointer<cvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_mfcc_do');
  late final _aubio_mfcc_do = _aubio_mfcc_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_mfcc_t>, ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// set power parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \param power Raise norm of the input spectrum norm to this power before
  /// computing filterbank.  Defaults to `1`.
  ///
  /// See aubio_filterbank_set_power().
  int aubio_mfcc_set_power(
    ffi.Pointer<aubio_mfcc_t> mf,
    double power,
  ) {
    return _aubio_mfcc_set_power(
      mf,
      power,
    );
  }

  late final _aubio_mfcc_set_powerPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_mfcc_t>, smpl_t)>>(
      'aubio_mfcc_set_power');
  late final _aubio_mfcc_set_power = _aubio_mfcc_set_powerPtr
      .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>, double)>();

  /// get power parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \return current power parameter. Defaults to `1`.
  ///
  /// See aubio_filterbank_get_power().
  double aubio_mfcc_get_power(
    ffi.Pointer<aubio_mfcc_t> mf,
  ) {
    return _aubio_mfcc_get_power(
      mf,
    );
  }

  late final _aubio_mfcc_get_powerPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_mfcc_t>)>>(
          'aubio_mfcc_get_power');
  late final _aubio_mfcc_get_power = _aubio_mfcc_get_powerPtr
      .asFunction<double Function(ffi.Pointer<aubio_mfcc_t>)>();

  /// set scaling parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \param scale Scaling value to apply.
  ///
  /// Scales the output of the filterbank after taking its logarithm and before
  /// computing the DCT. Defaults to `1`.
  int aubio_mfcc_set_scale(
    ffi.Pointer<aubio_mfcc_t> mf,
    double scale,
  ) {
    return _aubio_mfcc_set_scale(
      mf,
      scale,
    );
  }

  late final _aubio_mfcc_set_scalePtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_mfcc_t>, smpl_t)>>(
      'aubio_mfcc_set_scale');
  late final _aubio_mfcc_set_scale = _aubio_mfcc_set_scalePtr
      .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>, double)>();

  /// get scaling parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \return current scaling parameter. Defaults to `1`.
  double aubio_mfcc_get_scale(
    ffi.Pointer<aubio_mfcc_t> mf,
  ) {
    return _aubio_mfcc_get_scale(
      mf,
    );
  }

  late final _aubio_mfcc_get_scalePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_mfcc_t>)>>(
          'aubio_mfcc_get_scale');
  late final _aubio_mfcc_get_scale = _aubio_mfcc_get_scalePtr
      .asFunction<double Function(ffi.Pointer<aubio_mfcc_t>)>();

  /// Mel filterbank initialization
  ///
  /// \param mf mfcc object
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The filterbank will be initialized with bands linearly spaced in the mel
  /// scale, from `fmin` to `fmax`.
  ///
  /// See also
  /// --------
  ///
  /// aubio_filterbank_set_mel_coeffs()
  int aubio_mfcc_set_mel_coeffs(
    ffi.Pointer<aubio_mfcc_t> mf,
    double fmin,
    double fmax,
  ) {
    return _aubio_mfcc_set_mel_coeffs(
      mf,
      fmin,
      fmax,
    );
  }

  late final _aubio_mfcc_set_mel_coeffsPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_mfcc_t>, smpl_t,
              smpl_t)>>('aubio_mfcc_set_mel_coeffs');
  late final _aubio_mfcc_set_mel_coeffs = _aubio_mfcc_set_mel_coeffsPtr
      .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>, double, double)>();

  /// Mel filterbank initialization
  ///
  /// \param mf mfcc object
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The bank of filters will be initalized to to cover linearly spaced bands in
  /// the Htk mel scale, from `fmin` to `fmax`.
  ///
  /// See also
  /// --------
  ///
  /// aubio_filterbank_set_mel_coeffs_htk()
  int aubio_mfcc_set_mel_coeffs_htk(
    ffi.Pointer<aubio_mfcc_t> mf,
    double fmin,
    double fmax,
  ) {
    return _aubio_mfcc_set_mel_coeffs_htk(
      mf,
      fmin,
      fmax,
    );
  }

  late final _aubio_mfcc_set_mel_coeffs_htkPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_mfcc_t>, smpl_t,
              smpl_t)>>('aubio_mfcc_set_mel_coeffs_htk');
  late final _aubio_mfcc_set_mel_coeffs_htk = _aubio_mfcc_set_mel_coeffs_htkPtr
      .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>, double, double)>();

  /// Mel filterbank initialization (Auditory Toolbox's parameters)
  ///
  /// \param mf mfcc object
  ///
  /// The filter coefficients are built to match exactly Malcolm Slaney's Auditory
  /// Toolbox implementation. The number of filters should be 40.
  ///
  /// This is the default filterbank when `mf` was created with `n_filters = 40`.
  ///
  /// See also
  /// --------
  ///
  /// aubio_filterbank_set_mel_coeffs_slaney()
  int aubio_mfcc_set_mel_coeffs_slaney(
    ffi.Pointer<aubio_mfcc_t> mf,
  ) {
    return _aubio_mfcc_set_mel_coeffs_slaney(
      mf,
    );
  }

  late final _aubio_mfcc_set_mel_coeffs_slaneyPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_mfcc_t>)>>(
          'aubio_mfcc_set_mel_coeffs_slaney');
  late final _aubio_mfcc_set_mel_coeffs_slaney =
      _aubio_mfcc_set_mel_coeffs_slaneyPtr
          .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>)>();

  /// execute spectral description function on a spectral frame
  ///
  /// Generic function to compute spectral description.
  ///
  /// \param o spectral description object as returned by new_aubio_specdesc()
  /// \param fftgrain input signal spectrum as computed by aubio_pvoc_do
  /// \param desc output vector (one sample long, to send to the peak picking)
  void aubio_specdesc_do(
    ffi.Pointer<aubio_specdesc_t> o,
    ffi.Pointer<cvec_t> fftgrain,
    ffi.Pointer<fvec_t> desc,
  ) {
    return _aubio_specdesc_do(
      o,
      fftgrain,
      desc,
    );
  }

  late final _aubio_specdesc_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_specdesc_t>, ffi.Pointer<cvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_specdesc_do');
  late final _aubio_specdesc_do = _aubio_specdesc_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_specdesc_t>, ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// creation of a spectral description object
  ///
  /// \param method spectral description method
  /// \param buf_size length of the input spectrum frame
  ///
  /// The parameter \p method is a string that can be any of:
  ///
  /// - onset novelty functions: `complex`, `energy`, `hfc`, `kl`, `mkl`,
  /// `phase`, `specdiff`, `specflux`, `wphase`,
  ///
  /// - spectral descriptors: `centroid`, `decrease`, `kurtosis`, `rolloff`,
  /// `skewness`, `slope`, `spread`.
  ffi.Pointer<aubio_specdesc_t> new_aubio_specdesc(
    ffi.Pointer<char_t> method,
    int buf_size,
  ) {
    return _new_aubio_specdesc(
      method,
      buf_size,
    );
  }

  late final _new_aubio_specdescPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_specdesc_t> Function(
              ffi.Pointer<char_t>, uint_t)>>('new_aubio_specdesc');
  late final _new_aubio_specdesc = _new_aubio_specdescPtr.asFunction<
      ffi.Pointer<aubio_specdesc_t> Function(ffi.Pointer<char_t>, int)>();

  /// deletion of a spectral descriptor
  ///
  /// \param o spectral descriptor object as returned by new_aubio_specdesc()
  void del_aubio_specdesc(
    ffi.Pointer<aubio_specdesc_t> o,
  ) {
    return _del_aubio_specdesc(
      o,
    );
  }

  late final _del_aubio_specdescPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_specdesc_t>)>>(
      'del_aubio_specdesc');
  late final _del_aubio_specdesc = _del_aubio_specdescPtr
      .asFunction<void Function(ffi.Pointer<aubio_specdesc_t>)>();

  /// execute spectral adaptive whitening, in-place
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \param fftgrain input signal spectrum as computed by aubio_pvoc_do() or aubio_fft_do()
  void aubio_spectral_whitening_do(
    ffi.Pointer<aubio_spectral_whitening_t> o,
    ffi.Pointer<cvec_t> fftgrain,
  ) {
    return _aubio_spectral_whitening_do(
      o,
      fftgrain,
    );
  }

  late final _aubio_spectral_whitening_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_spectral_whitening_t>,
              ffi.Pointer<cvec_t>)>>('aubio_spectral_whitening_do');
  late final _aubio_spectral_whitening_do =
      _aubio_spectral_whitening_doPtr.asFunction<
          void Function(
              ffi.Pointer<aubio_spectral_whitening_t>, ffi.Pointer<cvec_t>)>();

  /// creation of a spectral whitening object
  ///
  /// \param buf_size window size of input grains
  /// \param hop_size number of samples between two consecutive input grains
  /// \param samplerate sampling rate of the input signal
  ffi.Pointer<aubio_spectral_whitening_t> new_aubio_spectral_whitening(
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_spectral_whitening(
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_spectral_whiteningPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_spectral_whitening_t> Function(
              uint_t, uint_t, uint_t)>>('new_aubio_spectral_whitening');
  late final _new_aubio_spectral_whitening =
      _new_aubio_spectral_whiteningPtr.asFunction<
          ffi.Pointer<aubio_spectral_whitening_t> Function(int, int, int)>();

  /// reset spectral whitening object
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  void aubio_spectral_whitening_reset(
    ffi.Pointer<aubio_spectral_whitening_t> o,
  ) {
    return _aubio_spectral_whitening_reset(
      o,
    );
  }

  late final _aubio_spectral_whitening_resetPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<aubio_spectral_whitening_t>)>>(
      'aubio_spectral_whitening_reset');
  late final _aubio_spectral_whitening_reset =
      _aubio_spectral_whitening_resetPtr
          .asFunction<void Function(ffi.Pointer<aubio_spectral_whitening_t>)>();

  /// set relaxation time for spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \param relax_time relaxation time in seconds between 20 and 500, defaults 250
  int aubio_spectral_whitening_set_relax_time(
    ffi.Pointer<aubio_spectral_whitening_t> o,
    double relax_time,
  ) {
    return _aubio_spectral_whitening_set_relax_time(
      o,
      relax_time,
    );
  }

  late final _aubio_spectral_whitening_set_relax_timePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_spectral_whitening_t>,
              smpl_t)>>('aubio_spectral_whitening_set_relax_time');
  late final _aubio_spectral_whitening_set_relax_time =
      _aubio_spectral_whitening_set_relax_timePtr.asFunction<
          int Function(ffi.Pointer<aubio_spectral_whitening_t>, double)>();

  /// get relaxation time of spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \return relaxation time in seconds
  double aubio_spectral_whitening_get_relax_time(
    ffi.Pointer<aubio_spectral_whitening_t> o,
  ) {
    return _aubio_spectral_whitening_get_relax_time(
      o,
    );
  }

  late final _aubio_spectral_whitening_get_relax_timePtr = _lookup<
          ffi.NativeFunction<
              smpl_t Function(ffi.Pointer<aubio_spectral_whitening_t>)>>(
      'aubio_spectral_whitening_get_relax_time');
  late final _aubio_spectral_whitening_get_relax_time =
      _aubio_spectral_whitening_get_relax_timePtr.asFunction<
          double Function(ffi.Pointer<aubio_spectral_whitening_t>)>();

  /// set floor for spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \param floor value (typically between 1.e-6 and .2, defaults to 1.e-4)
  int aubio_spectral_whitening_set_floor(
    ffi.Pointer<aubio_spectral_whitening_t> o,
    double floor,
  ) {
    return _aubio_spectral_whitening_set_floor(
      o,
      floor,
    );
  }

  late final _aubio_spectral_whitening_set_floorPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_spectral_whitening_t>,
              smpl_t)>>('aubio_spectral_whitening_set_floor');
  late final _aubio_spectral_whitening_set_floor =
      _aubio_spectral_whitening_set_floorPtr.asFunction<
          int Function(ffi.Pointer<aubio_spectral_whitening_t>, double)>();

  /// get floor of spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \return floor value
  double aubio_spectral_whitening_get_floor(
    ffi.Pointer<aubio_spectral_whitening_t> o,
  ) {
    return _aubio_spectral_whitening_get_floor(
      o,
    );
  }

  late final _aubio_spectral_whitening_get_floorPtr = _lookup<
          ffi.NativeFunction<
              smpl_t Function(ffi.Pointer<aubio_spectral_whitening_t>)>>(
      'aubio_spectral_whitening_get_floor');
  late final _aubio_spectral_whitening_get_floor =
      _aubio_spectral_whitening_get_floorPtr.asFunction<
          double Function(ffi.Pointer<aubio_spectral_whitening_t>)>();

  /// deletion of a spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  void del_aubio_spectral_whitening(
    ffi.Pointer<aubio_spectral_whitening_t> o,
  ) {
    return _del_aubio_spectral_whitening(
      o,
    );
  }

  late final _del_aubio_spectral_whiteningPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<aubio_spectral_whitening_t>)>>(
      'del_aubio_spectral_whitening');
  late final _del_aubio_spectral_whitening = _del_aubio_spectral_whiteningPtr
      .asFunction<void Function(ffi.Pointer<aubio_spectral_whitening_t>)>();

  /// create tss object
  ///
  /// \param buf_size buffer size
  /// \param hop_size step size
  ffi.Pointer<aubio_tss_t> new_aubio_tss(
    int buf_size,
    int hop_size,
  ) {
    return _new_aubio_tss(
      buf_size,
      hop_size,
    );
  }

  late final _new_aubio_tssPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_tss_t> Function(uint_t, uint_t)>>('new_aubio_tss');
  late final _new_aubio_tss = _new_aubio_tssPtr
      .asFunction<ffi.Pointer<aubio_tss_t> Function(int, int)>();

  /// delete tss object
  ///
  /// \param o tss object as returned by new_aubio_tss()
  void del_aubio_tss(
    ffi.Pointer<aubio_tss_t> o,
  ) {
    return _del_aubio_tss(
      o,
    );
  }

  late final _del_aubio_tssPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_tss_t>)>>(
          'del_aubio_tss');
  late final _del_aubio_tss =
      _del_aubio_tssPtr.asFunction<void Function(ffi.Pointer<aubio_tss_t>)>();

  /// split input into transient and steady states components
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param input input spectral frame
  /// \param trans output transient components
  /// \param stead output steady state components
  void aubio_tss_do(
    ffi.Pointer<aubio_tss_t> o,
    ffi.Pointer<cvec_t> input,
    ffi.Pointer<cvec_t> trans,
    ffi.Pointer<cvec_t> stead,
  ) {
    return _aubio_tss_do(
      o,
      input,
      trans,
      stead,
    );
  }

  late final _aubio_tss_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_tss_t>, ffi.Pointer<cvec_t>,
              ffi.Pointer<cvec_t>, ffi.Pointer<cvec_t>)>>('aubio_tss_do');
  late final _aubio_tss_do = _aubio_tss_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_tss_t>, ffi.Pointer<cvec_t>,
          ffi.Pointer<cvec_t>, ffi.Pointer<cvec_t>)>();

  /// set transient / steady state separation threshold
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param thrs new threshold value
  int aubio_tss_set_threshold(
    ffi.Pointer<aubio_tss_t> o,
    double thrs,
  ) {
    return _aubio_tss_set_threshold(
      o,
      thrs,
    );
  }

  late final _aubio_tss_set_thresholdPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_tss_t>, smpl_t)>>(
      'aubio_tss_set_threshold');
  late final _aubio_tss_set_threshold = _aubio_tss_set_thresholdPtr
      .asFunction<int Function(ffi.Pointer<aubio_tss_t>, double)>();

  /// set parameter a, defaults to 3
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param alpha new value for alpha parameter
  int aubio_tss_set_alpha(
    ffi.Pointer<aubio_tss_t> o,
    double alpha,
  ) {
    return _aubio_tss_set_alpha(
      o,
      alpha,
    );
  }

  late final _aubio_tss_set_alphaPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_tss_t>, smpl_t)>>(
      'aubio_tss_set_alpha');
  late final _aubio_tss_set_alpha = _aubio_tss_set_alphaPtr
      .asFunction<int Function(ffi.Pointer<aubio_tss_t>, double)>();

  /// set parameter b, defaults to 3
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param beta new value for beta parameter
  int aubio_tss_set_beta(
    ffi.Pointer<aubio_tss_t> o,
    double beta,
  ) {
    return _aubio_tss_set_beta(
      o,
      beta,
    );
  }

  late final _aubio_tss_set_betaPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_tss_t>, smpl_t)>>(
      'aubio_tss_set_beta');
  late final _aubio_tss_set_beta = _aubio_tss_set_betaPtr
      .asFunction<int Function(ffi.Pointer<aubio_tss_t>, double)>();

  /// execute pitch detection on an input signal frame
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param in input signal of size [hop_size]
  /// \param out output pitch candidates of size [1]
  void aubio_pitch_do(
    ffi.Pointer<aubio_pitch_t> o,
    ffi.Pointer<fvec_t> in1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_pitch_do(
      o,
      in1,
      out,
    );
  }

  late final _aubio_pitch_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_pitch_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pitch_do');
  late final _aubio_pitch_do = _aubio_pitch_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pitch_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// change yin or yinfft tolerance threshold
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param tol tolerance default is 0.15 for yin and 0.85 for yinfft
  int aubio_pitch_set_tolerance(
    ffi.Pointer<aubio_pitch_t> o,
    double tol,
  ) {
    return _aubio_pitch_set_tolerance(
      o,
      tol,
    );
  }

  late final _aubio_pitch_set_tolerancePtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_pitch_t>, smpl_t)>>(
      'aubio_pitch_set_tolerance');
  late final _aubio_pitch_set_tolerance = _aubio_pitch_set_tolerancePtr
      .asFunction<int Function(ffi.Pointer<aubio_pitch_t>, double)>();

  /// get yin or yinfft tolerance threshold
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \return tolerance (default is 0.15 for yin and 0.85 for yinfft)
  double aubio_pitch_get_tolerance(
    ffi.Pointer<aubio_pitch_t> o,
  ) {
    return _aubio_pitch_get_tolerance(
      o,
    );
  }

  late final _aubio_pitch_get_tolerancePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitch_t>)>>(
          'aubio_pitch_get_tolerance');
  late final _aubio_pitch_get_tolerance = _aubio_pitch_get_tolerancePtr
      .asFunction<double Function(ffi.Pointer<aubio_pitch_t>)>();

  /// deletion of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  void del_aubio_pitch(
    ffi.Pointer<aubio_pitch_t> o,
  ) {
    return _del_aubio_pitch(
      o,
    );
  }

  late final _del_aubio_pitchPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_pitch_t>)>>(
      'del_aubio_pitch');
  late final _del_aubio_pitch = _del_aubio_pitchPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitch_t>)>();

  /// creation of the pitch detection object
  ///
  /// \param method set pitch detection algorithm
  /// \param buf_size size of the input buffer to analyse
  /// \param hop_size step size between two consecutive analysis instant
  /// \param samplerate sampling rate of the signal
  ///
  /// \return newly created ::aubio_pitch_t
  ffi.Pointer<aubio_pitch_t> new_aubio_pitch(
    ffi.Pointer<char_t> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_pitch(
      method,
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_pitchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_pitch_t> Function(
              ffi.Pointer<char_t>, uint_t, uint_t, uint_t)>>('new_aubio_pitch');
  late final _new_aubio_pitch = _new_aubio_pitchPtr.asFunction<
      ffi.Pointer<aubio_pitch_t> Function(
          ffi.Pointer<char_t>, int, int, int)>();

  /// set the output unit of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param mode set pitch units for output
  ///
  /// mode can be one of "Hz", "midi", "cent", or "bin". Defaults to "Hz".
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_pitch_set_unit(
    ffi.Pointer<aubio_pitch_t> o,
    ffi.Pointer<char_t> mode,
  ) {
    return _aubio_pitch_set_unit(
      o,
      mode,
    );
  }

  late final _aubio_pitch_set_unitPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pitch_t>,
              ffi.Pointer<char_t>)>>('aubio_pitch_set_unit');
  late final _aubio_pitch_set_unit = _aubio_pitch_set_unitPtr.asFunction<
      int Function(ffi.Pointer<aubio_pitch_t>, ffi.Pointer<char_t>)>();

  /// set the silence threshold of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param silence level threshold under which pitch should be ignored, in dB
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_pitch_set_silence(
    ffi.Pointer<aubio_pitch_t> o,
    double silence,
  ) {
    return _aubio_pitch_set_silence(
      o,
      silence,
    );
  }

  late final _aubio_pitch_set_silencePtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_pitch_t>, smpl_t)>>(
      'aubio_pitch_set_silence');
  late final _aubio_pitch_set_silence = _aubio_pitch_set_silencePtr
      .asFunction<int Function(ffi.Pointer<aubio_pitch_t>, double)>();

  /// set the silence threshold of the pitch detection object
  ///
  /// \param o pitch detection object as returned by ::new_aubio_pitch()
  ///
  /// \return level threshold under which pitch should be ignored, in dB
  double aubio_pitch_get_silence(
    ffi.Pointer<aubio_pitch_t> o,
  ) {
    return _aubio_pitch_get_silence(
      o,
    );
  }

  late final _aubio_pitch_get_silencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitch_t>)>>(
          'aubio_pitch_get_silence');
  late final _aubio_pitch_get_silence = _aubio_pitch_get_silencePtr
      .asFunction<double Function(ffi.Pointer<aubio_pitch_t>)>();

  /// get the current confidence
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  ///
  /// \return the current confidence of the pitch algorithm
  double aubio_pitch_get_confidence(
    ffi.Pointer<aubio_pitch_t> o,
  ) {
    return _aubio_pitch_get_confidence(
      o,
    );
  }

  late final _aubio_pitch_get_confidencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitch_t>)>>(
          'aubio_pitch_get_confidence');
  late final _aubio_pitch_get_confidence = _aubio_pitch_get_confidencePtr
      .asFunction<double Function(ffi.Pointer<aubio_pitch_t>)>();

  /// create onset detection object
  ///
  /// \param method onset detection type as specified in specdesc.h
  /// \param buf_size buffer size for phase vocoder
  /// \param hop_size hop size for phase vocoder
  /// \param samplerate sampling rate of the input signal
  ///
  /// \return newly created ::aubio_onset_t
  ffi.Pointer<aubio_onset_t> new_aubio_onset(
    ffi.Pointer<char_t> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_onset(
      method,
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_onsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_onset_t> Function(
              ffi.Pointer<char_t>, uint_t, uint_t, uint_t)>>('new_aubio_onset');
  late final _new_aubio_onset = _new_aubio_onsetPtr.asFunction<
      ffi.Pointer<aubio_onset_t> Function(
          ffi.Pointer<char_t>, int, int, int)>();

  /// execute onset detection
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param input new audio vector of length hop_size
  /// \param onset output vector of length 1, containing 0 if no onset was found,
  /// and a value equal or greater than 1 otherwise
  ///
  /// When no onset was detected, the first element of the output vector `onset`
  /// is set to 0.
  ///
  /// When an onset is found, the first element of the output vector `onset` is set
  /// to `offset = 1 + a` where `a` is a number in the range`[0, 1]`.
  ///
  /// The final onset detection time, in samples, can be obtained with
  /// aubio_onset_get_last(). It can also be derived from `offset` as
  /// follows:
  ///
  /// \code
  /// t = total_frames + offset * hop_size - delay
  /// \endcode
  ///
  /// where `total_frames` is the total number of frames processed so far, and
  /// `delay` is the current delay of the onset object, as returned by
  /// aubio_onset_get_delay().
  void aubio_onset_do(
    ffi.Pointer<aubio_onset_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> onset,
  ) {
    return _aubio_onset_do(
      o,
      input,
      onset,
    );
  }

  late final _aubio_onset_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_onset_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_onset_do');
  late final _aubio_onset_do = _aubio_onset_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_onset_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// get the time of the latest onset detected, in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return onset detection timestamps (in samples)
  int aubio_onset_get_last(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_last(
      o,
    );
  }

  late final _aubio_onset_get_lastPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_last');
  late final _aubio_onset_get_last = _aubio_onset_get_lastPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>)>();

  /// get the time of the latest onset detected, in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return onset detection timestamps (in seconds)
  double aubio_onset_get_last_s(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_last_s(
      o,
    );
  }

  late final _aubio_onset_get_last_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_last_s');
  late final _aubio_onset_get_last_s = _aubio_onset_get_last_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get the time of the latest onset detected, in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return onset detection timestamps (in milliseconds)
  double aubio_onset_get_last_ms(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_last_ms(
      o,
    );
  }

  late final _aubio_onset_get_last_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_last_ms');
  late final _aubio_onset_get_last_ms = _aubio_onset_get_last_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set onset detection adaptive whitening
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param enable 1 to enable, 0 to disable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_onset_set_awhitening(
    ffi.Pointer<aubio_onset_t> o,
    int enable,
  ) {
    return _aubio_onset_set_awhitening(
      o,
      enable,
    );
  }

  late final _aubio_onset_set_awhiteningPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, uint_t)>>(
      'aubio_onset_set_awhitening');
  late final _aubio_onset_set_awhitening = _aubio_onset_set_awhiteningPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, int)>();

  /// get onset detection adaptive whitening
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return 1 if enabled, 0 otherwise
  double aubio_onset_get_awhitening(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_awhitening(
      o,
    );
  }

  late final _aubio_onset_get_awhiteningPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_awhitening');
  late final _aubio_onset_get_awhitening = _aubio_onset_get_awhiteningPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set or disable log compression
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param lambda logarithmic compression factor, 0 to disable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_onset_set_compression(
    ffi.Pointer<aubio_onset_t> o,
    double lambda,
  ) {
    return _aubio_onset_set_compression(
      o,
      lambda,
    );
  }

  late final _aubio_onset_set_compressionPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>>(
      'aubio_onset_set_compression');
  late final _aubio_onset_set_compression = _aubio_onset_set_compressionPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// get onset detection log compression
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \returns 0 if disabled, compression factor otherwise
  double aubio_onset_get_compression(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_compression(
      o,
    );
  }

  late final _aubio_onset_get_compressionPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_compression');
  late final _aubio_onset_get_compression = _aubio_onset_get_compressionPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set onset detection silence threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param silence new silence detection threshold
  int aubio_onset_set_silence(
    ffi.Pointer<aubio_onset_t> o,
    double silence,
  ) {
    return _aubio_onset_set_silence(
      o,
      silence,
    );
  }

  late final _aubio_onset_set_silencePtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>>(
      'aubio_onset_set_silence');
  late final _aubio_onset_set_silence = _aubio_onset_set_silencePtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// get onset detection silence threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return current silence threshold
  double aubio_onset_get_silence(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_silence(
      o,
    );
  }

  late final _aubio_onset_get_silencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_silence');
  late final _aubio_onset_get_silence = _aubio_onset_get_silencePtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get onset detection function
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return the current value of the descriptor
  double aubio_onset_get_descriptor(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_descriptor(
      o,
    );
  }

  late final _aubio_onset_get_descriptorPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_descriptor');
  late final _aubio_onset_get_descriptor = _aubio_onset_get_descriptorPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get thresholded onset detection function
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return the value of the thresholded descriptor
  double aubio_onset_get_thresholded_descriptor(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_thresholded_descriptor(
      o,
    );
  }

  late final _aubio_onset_get_thresholded_descriptorPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_thresholded_descriptor');
  late final _aubio_onset_get_thresholded_descriptor =
      _aubio_onset_get_thresholded_descriptorPtr
          .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set onset detection peak picking threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param threshold new peak-picking threshold
  int aubio_onset_set_threshold(
    ffi.Pointer<aubio_onset_t> o,
    double threshold,
  ) {
    return _aubio_onset_set_threshold(
      o,
      threshold,
    );
  }

  late final _aubio_onset_set_thresholdPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>>(
      'aubio_onset_set_threshold');
  late final _aubio_onset_set_threshold = _aubio_onset_set_thresholdPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// set minimum inter onset interval in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param minioi minimum interval between two consecutive onsets (in
  /// samples)
  int aubio_onset_set_minioi(
    ffi.Pointer<aubio_onset_t> o,
    int minioi,
  ) {
    return _aubio_onset_set_minioi(
      o,
      minioi,
    );
  }

  late final _aubio_onset_set_minioiPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, uint_t)>>(
      'aubio_onset_set_minioi');
  late final _aubio_onset_set_minioi = _aubio_onset_set_minioiPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, int)>();

  /// set minimum inter onset interval in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param minioi minimum interval between two consecutive onsets (in
  /// seconds)
  int aubio_onset_set_minioi_s(
    ffi.Pointer<aubio_onset_t> o,
    double minioi,
  ) {
    return _aubio_onset_set_minioi_s(
      o,
      minioi,
    );
  }

  late final _aubio_onset_set_minioi_sPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>>(
      'aubio_onset_set_minioi_s');
  late final _aubio_onset_set_minioi_s = _aubio_onset_set_minioi_sPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// set minimum inter onset interval in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param minioi minimum interval between two consecutive onsets (in
  /// milliseconds)
  int aubio_onset_set_minioi_ms(
    ffi.Pointer<aubio_onset_t> o,
    double minioi,
  ) {
    return _aubio_onset_set_minioi_ms(
      o,
      minioi,
    );
  }

  late final _aubio_onset_set_minioi_msPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>>(
      'aubio_onset_set_minioi_ms');
  late final _aubio_onset_set_minioi_ms = _aubio_onset_set_minioi_msPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// set delay in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param delay constant system delay to take back from detection time
  /// (in samples)
  int aubio_onset_set_delay(
    ffi.Pointer<aubio_onset_t> o,
    int delay,
  ) {
    return _aubio_onset_set_delay(
      o,
      delay,
    );
  }

  late final _aubio_onset_set_delayPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, uint_t)>>(
      'aubio_onset_set_delay');
  late final _aubio_onset_set_delay = _aubio_onset_set_delayPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, int)>();

  /// set delay in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param delay constant system delay to take back from detection time
  /// (in seconds)
  int aubio_onset_set_delay_s(
    ffi.Pointer<aubio_onset_t> o,
    double delay,
  ) {
    return _aubio_onset_set_delay_s(
      o,
      delay,
    );
  }

  late final _aubio_onset_set_delay_sPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>>(
      'aubio_onset_set_delay_s');
  late final _aubio_onset_set_delay_s = _aubio_onset_set_delay_sPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// set delay in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param delay constant system delay to take back from detection time
  /// (in milliseconds)
  int aubio_onset_set_delay_ms(
    ffi.Pointer<aubio_onset_t> o,
    double delay,
  ) {
    return _aubio_onset_set_delay_ms(
      o,
      delay,
    );
  }

  late final _aubio_onset_set_delay_msPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>>(
      'aubio_onset_set_delay_ms');
  late final _aubio_onset_set_delay_ms = _aubio_onset_set_delay_msPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// get minimum inter onset interval in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return minimum interval between two consecutive onsets (in
  /// samples)
  int aubio_onset_get_minioi(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_minioi(
      o,
    );
  }

  late final _aubio_onset_get_minioiPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_minioi');
  late final _aubio_onset_get_minioi = _aubio_onset_get_minioiPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>)>();

  /// get minimum inter onset interval in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return minimum interval between two consecutive onsets (in
  /// seconds)
  double aubio_onset_get_minioi_s(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_minioi_s(
      o,
    );
  }

  late final _aubio_onset_get_minioi_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_minioi_s');
  late final _aubio_onset_get_minioi_s = _aubio_onset_get_minioi_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get minimum inter onset interval in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return minimum interval between two consecutive onsets (in
  /// milliseconds)
  double aubio_onset_get_minioi_ms(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_minioi_ms(
      o,
    );
  }

  late final _aubio_onset_get_minioi_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_minioi_ms');
  late final _aubio_onset_get_minioi_ms = _aubio_onset_get_minioi_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get delay in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return constant system delay to take back from detection time
  /// (in samples)
  int aubio_onset_get_delay(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_delay(
      o,
    );
  }

  late final _aubio_onset_get_delayPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_delay');
  late final _aubio_onset_get_delay = _aubio_onset_get_delayPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>)>();

  /// get delay in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return constant system delay to take back from detection time
  /// (in seconds)
  double aubio_onset_get_delay_s(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_delay_s(
      o,
    );
  }

  late final _aubio_onset_get_delay_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_delay_s');
  late final _aubio_onset_get_delay_s = _aubio_onset_get_delay_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get delay in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return constant system delay to take back from detection time
  /// (in milliseconds)
  double aubio_onset_get_delay_ms(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_delay_ms(
      o,
    );
  }

  late final _aubio_onset_get_delay_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_delay_ms');
  late final _aubio_onset_get_delay_ms = _aubio_onset_get_delay_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get onset peak picking threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return current onset detection threshold
  double aubio_onset_get_threshold(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_get_threshold(
      o,
    );
  }

  late final _aubio_onset_get_thresholdPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
          'aubio_onset_get_threshold');
  late final _aubio_onset_get_threshold = _aubio_onset_get_thresholdPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set default parameters
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param onset_mode detection mode to adjust
  ///
  /// This function is called at the end of new_aubio_onset().
  int aubio_onset_set_default_parameters(
    ffi.Pointer<aubio_onset_t> o,
    ffi.Pointer<char_t> onset_mode,
  ) {
    return _aubio_onset_set_default_parameters(
      o,
      onset_mode,
    );
  }

  late final _aubio_onset_set_default_parametersPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_onset_t>,
              ffi.Pointer<char_t>)>>('aubio_onset_set_default_parameters');
  late final _aubio_onset_set_default_parameters =
      _aubio_onset_set_default_parametersPtr.asFunction<
          int Function(ffi.Pointer<aubio_onset_t>, ffi.Pointer<char_t>)>();

  /// reset onset detection
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// Reset current time and last onset to 0.
  ///
  /// This function is called at the end of new_aubio_onset().
  void aubio_onset_reset(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _aubio_onset_reset(
      o,
    );
  }

  late final _aubio_onset_resetPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_onset_t>)>>(
      'aubio_onset_reset');
  late final _aubio_onset_reset = _aubio_onset_resetPtr
      .asFunction<void Function(ffi.Pointer<aubio_onset_t>)>();

  /// delete onset detection object
  ///
  /// \param o onset detection object to delete
  void del_aubio_onset(
    ffi.Pointer<aubio_onset_t> o,
  ) {
    return _del_aubio_onset(
      o,
    );
  }

  late final _del_aubio_onsetPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_onset_t>)>>(
      'del_aubio_onset');
  late final _del_aubio_onset = _del_aubio_onsetPtr
      .asFunction<void Function(ffi.Pointer<aubio_onset_t>)>();

  /// create tempo detection object
  ///
  /// \param method beat tracking method, unused for now (use "default")
  /// \param buf_size length of FFT
  /// \param hop_size number of frames between two consecutive runs
  /// \param samplerate sampling rate of the signal to analyze
  ///
  /// \return newly created ::aubio_tempo_t if successful, `NULL` otherwise
  ffi.Pointer<aubio_tempo_t> new_aubio_tempo(
    ffi.Pointer<char_t> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_tempo(
      method,
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_tempoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_tempo_t> Function(
              ffi.Pointer<char_t>, uint_t, uint_t, uint_t)>>('new_aubio_tempo');
  late final _new_aubio_tempo = _new_aubio_tempoPtr.asFunction<
      ffi.Pointer<aubio_tempo_t> Function(
          ffi.Pointer<char_t>, int, int, int)>();

  /// execute tempo detection
  ///
  /// \param o beat tracking object
  /// \param input new samples
  /// \param tempo output beats
  void aubio_tempo_do(
    ffi.Pointer<aubio_tempo_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> tempo,
  ) {
    return _aubio_tempo_do(
      o,
      input,
      tempo,
    );
  }

  late final _aubio_tempo_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_tempo_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_tempo_do');
  late final _aubio_tempo_do = _aubio_tempo_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_tempo_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// get the time of the latest beat detected, in samples
  ///
  /// \param o tempo detection object as returned by ::new_aubio_tempo
  int aubio_tempo_get_last(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_last(
      o,
    );
  }

  late final _aubio_tempo_get_lastPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_last');
  late final _aubio_tempo_get_last = _aubio_tempo_get_lastPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get the time of the latest beat detected, in seconds
  ///
  /// \param o tempo detection object as returned by ::new_aubio_tempo
  double aubio_tempo_get_last_s(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_last_s(
      o,
    );
  }

  late final _aubio_tempo_get_last_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_last_s');
  late final _aubio_tempo_get_last_s = _aubio_tempo_get_last_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get the time of the latest beat detected, in milliseconds
  ///
  /// \param o tempo detection object as returned by ::new_aubio_tempo
  double aubio_tempo_get_last_ms(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_last_ms(
      o,
    );
  }

  late final _aubio_tempo_get_last_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_last_ms');
  late final _aubio_tempo_get_last_ms = _aubio_tempo_get_last_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// set tempo detection silence threshold
  ///
  /// \param o beat tracking object
  /// \param silence new silence threshold, in dB
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_silence(
    ffi.Pointer<aubio_tempo_t> o,
    double silence,
  ) {
    return _aubio_tempo_set_silence(
      o,
      silence,
    );
  }

  late final _aubio_tempo_set_silencePtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, smpl_t)>>(
      'aubio_tempo_set_silence');
  late final _aubio_tempo_set_silence = _aubio_tempo_set_silencePtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, double)>();

  /// get tempo detection silence threshold
  ///
  /// \param o tempo detection object as returned by new_aubio_tempo()
  ///
  /// \return current silence threshold
  double aubio_tempo_get_silence(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_silence(
      o,
    );
  }

  late final _aubio_tempo_get_silencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_silence');
  late final _aubio_tempo_get_silence = _aubio_tempo_get_silencePtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// set tempo detection peak picking threshold
  ///
  /// \param o beat tracking object
  /// \param threshold new threshold
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_threshold(
    ffi.Pointer<aubio_tempo_t> o,
    double threshold,
  ) {
    return _aubio_tempo_set_threshold(
      o,
      threshold,
    );
  }

  late final _aubio_tempo_set_thresholdPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, smpl_t)>>(
      'aubio_tempo_set_threshold');
  late final _aubio_tempo_set_threshold = _aubio_tempo_set_thresholdPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, double)>();

  /// get tempo peak picking threshold
  ///
  /// \param o tempo detection object as returned by new_aubio_tempo()
  ///
  /// \return current tempo detection threshold
  double aubio_tempo_get_threshold(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_threshold(
      o,
    );
  }

  late final _aubio_tempo_get_thresholdPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_threshold');
  late final _aubio_tempo_get_threshold = _aubio_tempo_get_thresholdPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current beat period in samples
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the currently observed period, in samples, or 0 if no consistent
  /// value is found.
  double aubio_tempo_get_period(
    ffi.Pointer<aubio_tempo_t> bt,
  ) {
    return _aubio_tempo_get_period(
      bt,
    );
  }

  late final _aubio_tempo_get_periodPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_period');
  late final _aubio_tempo_get_period = _aubio_tempo_get_periodPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current beat period in seconds
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the currently observed period, in seconds, or 0 if no consistent
  /// value is found.
  double aubio_tempo_get_period_s(
    ffi.Pointer<aubio_tempo_t> bt,
  ) {
    return _aubio_tempo_get_period_s(
      bt,
    );
  }

  late final _aubio_tempo_get_period_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_period_s');
  late final _aubio_tempo_get_period_s = _aubio_tempo_get_period_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current tempo
  ///
  /// \param o beat tracking object
  ///
  /// \return the currently observed tempo, or `0` if no consistent value is found
  double aubio_tempo_get_bpm(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_bpm(
      o,
    );
  }

  late final _aubio_tempo_get_bpmPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_bpm');
  late final _aubio_tempo_get_bpm = _aubio_tempo_get_bpmPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current tempo confidence
  ///
  /// \param o beat tracking object
  ///
  /// \return confidence with which the tempo has been observed, the higher the
  /// more confidence, `0` if no consistent value is found.
  double aubio_tempo_get_confidence(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_confidence(
      o,
    );
  }

  late final _aubio_tempo_get_confidencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_confidence');
  late final _aubio_tempo_get_confidence = _aubio_tempo_get_confidencePtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// set number of tatum per beat
  ///
  /// \param o beat tracking object
  /// \param signature number of tatum per beat (between 1 and 64)
  int aubio_tempo_set_tatum_signature(
    ffi.Pointer<aubio_tempo_t> o,
    int signature,
  ) {
    return _aubio_tempo_set_tatum_signature(
      o,
      signature,
    );
  }

  late final _aubio_tempo_set_tatum_signaturePtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, uint_t)>>(
      'aubio_tempo_set_tatum_signature');
  late final _aubio_tempo_set_tatum_signature =
      _aubio_tempo_set_tatum_signaturePtr
          .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, int)>();

  /// check whether a tatum was detected in the current frame
  ///
  /// \param o beat tracking object
  ///
  /// \return 2 if a beat was detected, 1 if a tatum was detected, 0 otherwise
  int aubio_tempo_was_tatum(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_was_tatum(
      o,
    );
  }

  late final _aubio_tempo_was_tatumPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_was_tatum');
  late final _aubio_tempo_was_tatum = _aubio_tempo_was_tatumPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get position of last_tatum, in samples
  ///
  /// \param o beat tracking object
  double aubio_tempo_get_last_tatum(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_last_tatum(
      o,
    );
  }

  late final _aubio_tempo_get_last_tatumPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_last_tatum');
  late final _aubio_tempo_get_last_tatum = _aubio_tempo_get_last_tatumPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current delay
  ///
  /// \param o beat tracking object
  ///
  /// \return current delay, in samples
  int aubio_tempo_get_delay(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_delay(
      o,
    );
  }

  late final _aubio_tempo_get_delayPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_delay');
  late final _aubio_tempo_get_delay = _aubio_tempo_get_delayPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current delay in seconds
  ///
  /// \param o beat tracking object
  ///
  /// \return current delay, in seconds
  double aubio_tempo_get_delay_s(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_delay_s(
      o,
    );
  }

  late final _aubio_tempo_get_delay_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_delay_s');
  late final _aubio_tempo_get_delay_s = _aubio_tempo_get_delay_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current delay in ms
  ///
  /// \param o beat tracking object
  ///
  /// \return current delay, in milliseconds
  double aubio_tempo_get_delay_ms(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_delay_ms(
      o,
    );
  }

  late final _aubio_tempo_get_delay_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
          'aubio_tempo_get_delay_ms');
  late final _aubio_tempo_get_delay_ms = _aubio_tempo_get_delay_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// set current delay
  ///
  /// \param o beat tracking object
  /// \param delay delay to set tempo to, in samples
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_delay(
    ffi.Pointer<aubio_tempo_t> o,
    int delay,
  ) {
    return _aubio_tempo_set_delay(
      o,
      delay,
    );
  }

  late final _aubio_tempo_set_delayPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, sint_t)>>(
      'aubio_tempo_set_delay');
  late final _aubio_tempo_set_delay = _aubio_tempo_set_delayPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, int)>();

  /// set current delay in seconds
  ///
  /// \param o beat tracking object
  /// \param delay delay to set tempo to, in seconds
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_delay_s(
    ffi.Pointer<aubio_tempo_t> o,
    double delay,
  ) {
    return _aubio_tempo_set_delay_s(
      o,
      delay,
    );
  }

  late final _aubio_tempo_set_delay_sPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, smpl_t)>>(
      'aubio_tempo_set_delay_s');
  late final _aubio_tempo_set_delay_s = _aubio_tempo_set_delay_sPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, double)>();

  /// set current delay
  ///
  /// \param o beat tracking object
  /// \param delay delay to set tempo to, in samples
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_delay_ms(
    ffi.Pointer<aubio_tempo_t> o,
    double delay,
  ) {
    return _aubio_tempo_set_delay_ms(
      o,
      delay,
    );
  }

  late final _aubio_tempo_set_delay_msPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, smpl_t)>>(
      'aubio_tempo_set_delay_ms');
  late final _aubio_tempo_set_delay_ms = _aubio_tempo_set_delay_msPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, double)>();

  /// delete tempo detection object
  ///
  /// \param o beat tracking object
  void del_aubio_tempo(
    ffi.Pointer<aubio_tempo_t> o,
  ) {
    return _del_aubio_tempo(
      o,
    );
  }

  late final _del_aubio_tempoPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_tempo_t>)>>(
      'del_aubio_tempo');
  late final _del_aubio_tempo = _del_aubio_tempoPtr
      .asFunction<void Function(ffi.Pointer<aubio_tempo_t>)>();

  /// create notes detection object
  ///
  /// \param method notes detection type as specified in specdesc.h
  /// \param buf_size buffer size for phase vocoder
  /// \param hop_size hop size for phase vocoder
  /// \param samplerate sampling rate of the input signal
  ///
  /// \return newly created ::aubio_notes_t
  ffi.Pointer<aubio_notes_t> new_aubio_notes(
    ffi.Pointer<char_t> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_notes(
      method,
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_notesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_notes_t> Function(
              ffi.Pointer<char_t>, uint_t, uint_t, uint_t)>>('new_aubio_notes');
  late final _new_aubio_notes = _new_aubio_notesPtr.asFunction<
      ffi.Pointer<aubio_notes_t> Function(
          ffi.Pointer<char_t>, int, int, int)>();

  /// delete notes detection object
  ///
  /// \param o notes detection object to delete
  void del_aubio_notes(
    ffi.Pointer<aubio_notes_t> o,
  ) {
    return _del_aubio_notes(
      o,
    );
  }

  late final _del_aubio_notesPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_notes_t>)>>(
      'del_aubio_notes');
  late final _del_aubio_notes = _del_aubio_notesPtr
      .asFunction<void Function(ffi.Pointer<aubio_notes_t>)>();

  /// execute note detection on an input signal frame
  ///
  /// \param o note detection object as returned by new_aubio_notes()
  /// \param input input signal of size [hop_size]
  /// \param output output notes, fvec of length 3
  ///
  /// The notes output is a vector of length 3 containing:
  /// - 0. the midi note value, or 0 if no note was found
  /// - 1. the note velocity
  /// - 2. the midi note to turn off
  void aubio_notes_do(
    ffi.Pointer<aubio_notes_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_notes_do(
      o,
      input,
      output,
    );
  }

  late final _aubio_notes_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_notes_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_notes_do');
  late final _aubio_notes_do = _aubio_notes_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_notes_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// set notes detection silence threshold
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  /// \param silence new silence detection threshold
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_notes_set_silence(
    ffi.Pointer<aubio_notes_t> o,
    double silence,
  ) {
    return _aubio_notes_set_silence(
      o,
      silence,
    );
  }

  late final _aubio_notes_set_silencePtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_notes_t>, smpl_t)>>(
      'aubio_notes_set_silence');
  late final _aubio_notes_set_silence = _aubio_notes_set_silencePtr
      .asFunction<int Function(ffi.Pointer<aubio_notes_t>, double)>();

  /// get notes detection silence threshold
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  ///
  /// \return current silence threshold
  double aubio_notes_get_silence(
    ffi.Pointer<aubio_notes_t> o,
  ) {
    return _aubio_notes_get_silence(
      o,
    );
  }

  late final _aubio_notes_get_silencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_notes_t>)>>(
          'aubio_notes_get_silence');
  late final _aubio_notes_get_silence = _aubio_notes_get_silencePtr
      .asFunction<double Function(ffi.Pointer<aubio_notes_t>)>();

  /// get notes detection minimum inter-onset interval, in millisecond
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  ///
  /// \return current minimum inter onset interval
  double aubio_notes_get_minioi_ms(
    ffi.Pointer<aubio_notes_t> o,
  ) {
    return _aubio_notes_get_minioi_ms(
      o,
    );
  }

  late final _aubio_notes_get_minioi_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_notes_t>)>>(
          'aubio_notes_get_minioi_ms');
  late final _aubio_notes_get_minioi_ms = _aubio_notes_get_minioi_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_notes_t>)>();

  /// set notes detection minimum inter-onset interval, in millisecond
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  /// \param minioi_ms new inter-onset interval
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_notes_set_minioi_ms(
    ffi.Pointer<aubio_notes_t> o,
    double minioi_ms,
  ) {
    return _aubio_notes_set_minioi_ms(
      o,
      minioi_ms,
    );
  }

  late final _aubio_notes_set_minioi_msPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_notes_t>, smpl_t)>>(
      'aubio_notes_set_minioi_ms');
  late final _aubio_notes_set_minioi_ms = _aubio_notes_set_minioi_msPtr
      .asFunction<int Function(ffi.Pointer<aubio_notes_t>, double)>();

  /// get notes object release drop level, in dB
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  ///
  /// \return current release drop level, in dB
  double aubio_notes_get_release_drop(
    ffi.Pointer<aubio_notes_t> o,
  ) {
    return _aubio_notes_get_release_drop(
      o,
    );
  }

  late final _aubio_notes_get_release_dropPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_notes_t>)>>(
          'aubio_notes_get_release_drop');
  late final _aubio_notes_get_release_drop = _aubio_notes_get_release_dropPtr
      .asFunction<double Function(ffi.Pointer<aubio_notes_t>)>();

  /// set note release drop level, in dB
  ///
  /// This function sets the release_drop_level parameter, in dB. When a new note
  /// is found, the current level in dB is measured. If the measured level drops
  /// under that initial level - release_drop_level, then a note-off will be
  /// emitted.
  ///
  /// Defaults to `10`, in dB.
  ///
  /// \note This parameter was added in version `0.4.8`. Results obtained with
  /// earlier versions can be reproduced by setting this value to `100`, so that
  /// note-off will not be played until the next note.
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  /// \param release_drop new release drop level, in dB
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_notes_set_release_drop(
    ffi.Pointer<aubio_notes_t> o,
    double release_drop,
  ) {
    return _aubio_notes_set_release_drop(
      o,
      release_drop,
    );
  }

  late final _aubio_notes_set_release_dropPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_notes_t>, smpl_t)>>(
      'aubio_notes_set_release_drop');
  late final _aubio_notes_set_release_drop = _aubio_notes_set_release_dropPtr
      .asFunction<int Function(ffi.Pointer<aubio_notes_t>, double)>();

  /// create new ::aubio_source_t
  ///
  /// \param uri the file path or uri to read from
  /// \param samplerate sampling rate to view the fie at
  /// \param hop_size the size of the blocks to read from
  ///
  /// Creates a new source object. If `0` is passed as `samplerate`, the sample
  /// rate of the original file is used.
  ///
  /// The samplerate of newly created source can be obtained using
  /// ::aubio_source_get_samplerate.
  ffi.Pointer<aubio_source_t> new_aubio_source(
    ffi.Pointer<char_t> uri,
    int samplerate,
    int hop_size,
  ) {
    return _new_aubio_source(
      uri,
      samplerate,
      hop_size,
    );
  }

  late final _new_aubio_sourcePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_source_t> Function(
              ffi.Pointer<char_t>, uint_t, uint_t)>>('new_aubio_source');
  late final _new_aubio_source = _new_aubio_sourcePtr.asFunction<
      ffi.Pointer<aubio_source_t> Function(ffi.Pointer<char_t>, int, int)>();

  /// read monophonic vector of length hop_size from source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \param read_to ::fvec_t of data to read to
  /// \param read upon returns, equals to number of frames actually read
  ///
  /// Upon returns, `read` contains the number of frames actually read from the
  /// source. `hop_size` if enough frames could be read, less otherwise.
  void aubio_source_do(
    ffi.Pointer<aubio_source_t> s,
    ffi.Pointer<fvec_t> read_to,
    ffi.Pointer<uint_t> read,
  ) {
    return _aubio_source_do(
      s,
      read_to,
      read,
    );
  }

  late final _aubio_source_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_source_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<uint_t>)>>('aubio_source_do');
  late final _aubio_source_do = _aubio_source_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_source_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<uint_t>)>();

  /// read polyphonic vector of length hop_size from source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \param read_to ::fmat_t of data to read to
  /// \param[out] read upon returns, equals to number of frames actually read
  ///
  /// Upon returns, `read` contains the number of frames actually read from the
  /// source. `hop_size` if enough frames could be read, less otherwise.
  void aubio_source_do_multi(
    ffi.Pointer<aubio_source_t> s,
    ffi.Pointer<fmat_t> read_to,
    ffi.Pointer<uint_t> read,
  ) {
    return _aubio_source_do_multi(
      s,
      read_to,
      read,
    );
  }

  late final _aubio_source_do_multiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_source_t>, ffi.Pointer<fmat_t>,
              ffi.Pointer<uint_t>)>>('aubio_source_do_multi');
  late final _aubio_source_do_multi = _aubio_source_do_multiPtr.asFunction<
      void Function(ffi.Pointer<aubio_source_t>, ffi.Pointer<fmat_t>,
          ffi.Pointer<uint_t>)>();

  /// get samplerate of source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \return samplerate, in Hz
  int aubio_source_get_samplerate(
    ffi.Pointer<aubio_source_t> s,
  ) {
    return _aubio_source_get_samplerate(
      s,
    );
  }

  late final _aubio_source_get_sampleratePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_source_t>)>>(
          'aubio_source_get_samplerate');
  late final _aubio_source_get_samplerate = _aubio_source_get_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>)>();

  /// get channels of source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \return channels
  int aubio_source_get_channels(
    ffi.Pointer<aubio_source_t> s,
  ) {
    return _aubio_source_get_channels(
      s,
    );
  }

  late final _aubio_source_get_channelsPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_source_t>)>>(
          'aubio_source_get_channels');
  late final _aubio_source_get_channels = _aubio_source_get_channelsPtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>)>();

  /// seek source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \param pos position to seek to, in frames
  ///
  /// \return 0 if sucessful, non-zero on failure
  int aubio_source_seek(
    ffi.Pointer<aubio_source_t> s,
    int pos,
  ) {
    return _aubio_source_seek(
      s,
      pos,
    );
  }

  late final _aubio_source_seekPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(
              ffi.Pointer<aubio_source_t>, uint_t)>>('aubio_source_seek');
  late final _aubio_source_seek = _aubio_source_seekPtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>, int)>();

  /// get the duration of source object, in frames
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \return number of frames in file
  int aubio_source_get_duration(
    ffi.Pointer<aubio_source_t> s,
  ) {
    return _aubio_source_get_duration(
      s,
    );
  }

  late final _aubio_source_get_durationPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_source_t>)>>(
          'aubio_source_get_duration');
  late final _aubio_source_get_duration = _aubio_source_get_durationPtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>)>();

  /// close source object
  ///
  /// \param s source object, created with ::new_aubio_source
  ///
  /// \return 0 if sucessful, non-zero on failure
  int aubio_source_close(
    ffi.Pointer<aubio_source_t> s,
  ) {
    return _aubio_source_close(
      s,
    );
  }

  late final _aubio_source_closePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_source_t>)>>(
          'aubio_source_close');
  late final _aubio_source_close = _aubio_source_closePtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>)>();

  /// close source and cleanup memory
  ///
  /// \param s source object, created with ::new_aubio_source
  void del_aubio_source(
    ffi.Pointer<aubio_source_t> s,
  ) {
    return _del_aubio_source(
      s,
    );
  }

  late final _del_aubio_sourcePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_source_t>)>>(
      'del_aubio_source');
  late final _del_aubio_source = _del_aubio_sourcePtr
      .asFunction<void Function(ffi.Pointer<aubio_source_t>)>();

  /// create new ::aubio_sink_t
  ///
  /// \param uri the file path or uri to write to
  /// \param samplerate sample rate to write the file at
  ///
  /// \return newly created ::aubio_sink_t
  ///
  /// Creates a new sink object.
  ///
  /// If samplerate is set to 0, the creation of the file will be delayed until
  /// both ::aubio_sink_preset_samplerate and ::aubio_sink_preset_channels have
  /// been called.
  ffi.Pointer<aubio_sink_t> new_aubio_sink(
    ffi.Pointer<char_t> uri,
    int samplerate,
  ) {
    return _new_aubio_sink(
      uri,
      samplerate,
    );
  }

  late final _new_aubio_sinkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_sink_t> Function(
              ffi.Pointer<char_t>, uint_t)>>('new_aubio_sink');
  late final _new_aubio_sink = _new_aubio_sinkPtr.asFunction<
      ffi.Pointer<aubio_sink_t> Function(ffi.Pointer<char_t>, int)>();

  /// preset sink samplerate
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param samplerate samplerate to preset the sink to, in Hz
  ///
  /// \return 0 on success, 1 on error
  ///
  /// Preset the samplerate of the sink. The file should have been created using a
  /// samplerate of 0.
  ///
  /// The file will be opened only when both samplerate and channels have been set.
  int aubio_sink_preset_samplerate(
    ffi.Pointer<aubio_sink_t> s,
    int samplerate,
  ) {
    return _aubio_sink_preset_samplerate(
      s,
      samplerate,
    );
  }

  late final _aubio_sink_preset_sampleratePtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>, uint_t)>>(
      'aubio_sink_preset_samplerate');
  late final _aubio_sink_preset_samplerate = _aubio_sink_preset_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>, int)>();

  /// preset sink channels
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param channels number of channels to preset the sink to
  ///
  /// \return 0 on success, 1 on error
  ///
  /// Preset the samplerate of the sink. The file should have been created using a
  /// samplerate of 0.
  ///
  /// The file will be opened only when both samplerate and channels have been set.
  int aubio_sink_preset_channels(
    ffi.Pointer<aubio_sink_t> s,
    int channels,
  ) {
    return _aubio_sink_preset_channels(
      s,
      channels,
    );
  }

  late final _aubio_sink_preset_channelsPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>, uint_t)>>(
      'aubio_sink_preset_channels');
  late final _aubio_sink_preset_channels = _aubio_sink_preset_channelsPtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>, int)>();

  /// get samplerate of sink object
  ///
  /// \param s sink object, created with ::new_aubio_sink
  /// \return samplerate, in Hz
  int aubio_sink_get_samplerate(
    ffi.Pointer<aubio_sink_t> s,
  ) {
    return _aubio_sink_get_samplerate(
      s,
    );
  }

  late final _aubio_sink_get_sampleratePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>)>>(
          'aubio_sink_get_samplerate');
  late final _aubio_sink_get_samplerate = _aubio_sink_get_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>)>();

  /// get channels of sink object
  ///
  /// \param s sink object, created with ::new_aubio_sink
  /// \return number of channels
  int aubio_sink_get_channels(
    ffi.Pointer<aubio_sink_t> s,
  ) {
    return _aubio_sink_get_channels(
      s,
    );
  }

  late final _aubio_sink_get_channelsPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>)>>(
          'aubio_sink_get_channels');
  late final _aubio_sink_get_channels = _aubio_sink_get_channelsPtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>)>();

  /// write monophonic vector of length hop_size to sink
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param write_data ::fvec_t samples to write to sink
  /// \param write number of frames to write
  void aubio_sink_do(
    ffi.Pointer<aubio_sink_t> s,
    ffi.Pointer<fvec_t> write_data,
    int write,
  ) {
    return _aubio_sink_do(
      s,
      write_data,
      write,
    );
  }

  late final _aubio_sink_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_sink_t>, ffi.Pointer<fvec_t>,
              uint_t)>>('aubio_sink_do');
  late final _aubio_sink_do = _aubio_sink_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_sink_t>, ffi.Pointer<fvec_t>, int)>();

  /// write polyphonic vector of length hop_size to sink
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param write_data ::fmat_t samples to write to sink
  /// \param write number of frames to write
  void aubio_sink_do_multi(
    ffi.Pointer<aubio_sink_t> s,
    ffi.Pointer<fmat_t> write_data,
    int write,
  ) {
    return _aubio_sink_do_multi(
      s,
      write_data,
      write,
    );
  }

  late final _aubio_sink_do_multiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_sink_t>, ffi.Pointer<fmat_t>,
              uint_t)>>('aubio_sink_do_multi');
  late final _aubio_sink_do_multi = _aubio_sink_do_multiPtr.asFunction<
      void Function(ffi.Pointer<aubio_sink_t>, ffi.Pointer<fmat_t>, int)>();

  /// close sink
  ///
  /// \param s sink object, created with ::new_aubio_sink
  ///
  /// \return 0 on success, non-zero on failure
  int aubio_sink_close(
    ffi.Pointer<aubio_sink_t> s,
  ) {
    return _aubio_sink_close(
      s,
    );
  }

  late final _aubio_sink_closePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>)>>(
          'aubio_sink_close');
  late final _aubio_sink_close = _aubio_sink_closePtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>)>();

  /// close sink and cleanup memory
  ///
  /// \param s sink object, created with ::new_aubio_sink
  void del_aubio_sink(
    ffi.Pointer<aubio_sink_t> s,
  ) {
    return _del_aubio_sink(
      s,
    );
  }

  late final _del_aubio_sinkPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_sink_t>)>>(
          'del_aubio_sink');
  late final _del_aubio_sink =
      _del_aubio_sinkPtr.asFunction<void Function(ffi.Pointer<aubio_sink_t>)>();

  /// create new sampler object
  ///
  /// \param samplerate the sampling rate of the new sampler
  /// \param hop_size the block size of the new sampler
  ///
  /// \return the newly created ::aubio_sampler_t
  ffi.Pointer<aubio_sampler_t> new_aubio_sampler(
    int samplerate,
    int hop_size,
  ) {
    return _new_aubio_sampler(
      samplerate,
      hop_size,
    );
  }

  late final _new_aubio_samplerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_sampler_t> Function(
              uint_t, uint_t)>>('new_aubio_sampler');
  late final _new_aubio_sampler = _new_aubio_samplerPtr
      .asFunction<ffi.Pointer<aubio_sampler_t> Function(int, int)>();

  /// load source in sampler
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param uri the uri of the source to load
  ///
  /// \return 0 if successful, non-zero otherwise
  int aubio_sampler_load(
    ffi.Pointer<aubio_sampler_t> o,
    ffi.Pointer<char_t> uri,
  ) {
    return _aubio_sampler_load(
      o,
      uri,
    );
  }

  late final _aubio_sampler_loadPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_sampler_t>,
              ffi.Pointer<char_t>)>>('aubio_sampler_load');
  late final _aubio_sampler_load = _aubio_sampler_loadPtr.asFunction<
      int Function(ffi.Pointer<aubio_sampler_t>, ffi.Pointer<char_t>)>();

  /// process sampler function
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param input input of the sampler, to be added to the output
  /// \param output output of the sampler
  ///
  /// This function adds the new samples from the playing source to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_sampler_do(
    ffi.Pointer<aubio_sampler_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_sampler_do(
      o,
      input,
      output,
    );
  }

  late final _aubio_sampler_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_sampler_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_sampler_do');
  late final _aubio_sampler_do = _aubio_sampler_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_sampler_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// process sampler function, multiple channels
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param input input of the sampler, to be added to the output
  /// \param output output of the sampler
  ///
  /// This function adds the new samples from the playing source to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_sampler_do_multi(
    ffi.Pointer<aubio_sampler_t> o,
    ffi.Pointer<fmat_t> input,
    ffi.Pointer<fmat_t> output,
  ) {
    return _aubio_sampler_do_multi(
      o,
      input,
      output,
    );
  }

  late final _aubio_sampler_do_multiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_sampler_t>, ffi.Pointer<fmat_t>,
              ffi.Pointer<fmat_t>)>>('aubio_sampler_do_multi');
  late final _aubio_sampler_do_multi = _aubio_sampler_do_multiPtr.asFunction<
      void Function(ffi.Pointer<aubio_sampler_t>, ffi.Pointer<fmat_t>,
          ffi.Pointer<fmat_t>)>();

  /// get current playing state
  ///
  /// \param o sampler, created by new_aubio_sampler()
  ///
  /// \return 0 if not playing, 1 if playing
  int aubio_sampler_get_playing(
    ffi.Pointer<aubio_sampler_t> o,
  ) {
    return _aubio_sampler_get_playing(
      o,
    );
  }

  late final _aubio_sampler_get_playingPtr = _lookup<
          ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sampler_t>)>>(
      'aubio_sampler_get_playing');
  late final _aubio_sampler_get_playing = _aubio_sampler_get_playingPtr
      .asFunction<int Function(ffi.Pointer<aubio_sampler_t>)>();

  /// set current playing state
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param playing 0 for not playing, 1 for playing
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_sampler_set_playing(
    ffi.Pointer<aubio_sampler_t> o,
    int playing,
  ) {
    return _aubio_sampler_set_playing(
      o,
      playing,
    );
  }

  late final _aubio_sampler_set_playingPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_sampler_t>,
              uint_t)>>('aubio_sampler_set_playing');
  late final _aubio_sampler_set_playing = _aubio_sampler_set_playingPtr
      .asFunction<int Function(ffi.Pointer<aubio_sampler_t>, int)>();

  /// play sample from start
  ///
  /// \param o sampler, created by new_aubio_sampler()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_sampler_play(
    ffi.Pointer<aubio_sampler_t> o,
  ) {
    return _aubio_sampler_play(
      o,
    );
  }

  late final _aubio_sampler_playPtr = _lookup<
          ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sampler_t>)>>(
      'aubio_sampler_play');
  late final _aubio_sampler_play = _aubio_sampler_playPtr
      .asFunction<int Function(ffi.Pointer<aubio_sampler_t>)>();

  /// stop sample
  ///
  /// \param o sampler, created by new_aubio_sampler()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_sampler_stop(
    ffi.Pointer<aubio_sampler_t> o,
  ) {
    return _aubio_sampler_stop(
      o,
    );
  }

  late final _aubio_sampler_stopPtr = _lookup<
          ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sampler_t>)>>(
      'aubio_sampler_stop');
  late final _aubio_sampler_stop = _aubio_sampler_stopPtr
      .asFunction<int Function(ffi.Pointer<aubio_sampler_t>)>();

  /// destroy ::aubio_sampler_t object
  ///
  /// \param o sampler, created by new_aubio_sampler()
  void del_aubio_sampler(
    ffi.Pointer<aubio_sampler_t> o,
  ) {
    return _del_aubio_sampler(
      o,
    );
  }

  late final _del_aubio_samplerPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_sampler_t>)>>(
      'del_aubio_sampler');
  late final _del_aubio_sampler = _del_aubio_samplerPtr
      .asFunction<void Function(ffi.Pointer<aubio_sampler_t>)>();

  /// create new wavetable object
  ///
  /// \param samplerate the sampling rate of the new wavetable
  /// \param hop_size the block size of the new wavetable
  ///
  /// \return the newly created aubio_wavetable_t
  ffi.Pointer<aubio_wavetable_t> new_aubio_wavetable(
    int samplerate,
    int hop_size,
  ) {
    return _new_aubio_wavetable(
      samplerate,
      hop_size,
    );
  }

  late final _new_aubio_wavetablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_wavetable_t> Function(
              uint_t, uint_t)>>('new_aubio_wavetable');
  late final _new_aubio_wavetable = _new_aubio_wavetablePtr
      .asFunction<ffi.Pointer<aubio_wavetable_t> Function(int, int)>();

  /// load source in wavetable
  ///
  /// TODO: This function is not implemented yet. See new_aubio_sampler() instead.
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param uri the uri of the source to load
  ///
  /// \return 0 if successful, non-zero otherwise
  int aubio_wavetable_load(
    ffi.Pointer<aubio_wavetable_t> o,
    ffi.Pointer<char_t> uri,
  ) {
    return _aubio_wavetable_load(
      o,
      uri,
    );
  }

  late final _aubio_wavetable_loadPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_wavetable_t>,
              ffi.Pointer<char_t>)>>('aubio_wavetable_load');
  late final _aubio_wavetable_load = _aubio_wavetable_loadPtr.asFunction<
      int Function(ffi.Pointer<aubio_wavetable_t>, ffi.Pointer<char_t>)>();

  /// process wavetable function
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param input input of the wavetable, to be added to the output
  /// \param output output of the wavetable
  ///
  /// This function adds the new samples from the playing wavetable to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_wavetable_do(
    ffi.Pointer<aubio_wavetable_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_wavetable_do(
      o,
      input,
      output,
    );
  }

  late final _aubio_wavetable_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_wavetable_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_wavetable_do');
  late final _aubio_wavetable_do = _aubio_wavetable_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_wavetable_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// process wavetable function, multiple channels
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param input input of the wavetable, to be added to the output
  /// \param output output of the wavetable
  ///
  /// This function adds the new samples from the playing wavetable to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_wavetable_do_multi(
    ffi.Pointer<aubio_wavetable_t> o,
    ffi.Pointer<fmat_t> input,
    ffi.Pointer<fmat_t> output,
  ) {
    return _aubio_wavetable_do_multi(
      o,
      input,
      output,
    );
  }

  late final _aubio_wavetable_do_multiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_wavetable_t>, ffi.Pointer<fmat_t>,
              ffi.Pointer<fmat_t>)>>('aubio_wavetable_do_multi');
  late final _aubio_wavetable_do_multi =
      _aubio_wavetable_do_multiPtr.asFunction<
          void Function(ffi.Pointer<aubio_wavetable_t>, ffi.Pointer<fmat_t>,
              ffi.Pointer<fmat_t>)>();

  /// get current playing state
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return 0 if not playing, 1 if playing
  int aubio_wavetable_get_playing(
    ffi.Pointer<aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_get_playing(
      o,
    );
  }

  late final _aubio_wavetable_get_playingPtr = _lookup<
          ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_wavetable_t>)>>(
      'aubio_wavetable_get_playing');
  late final _aubio_wavetable_get_playing = _aubio_wavetable_get_playingPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// set current playing state
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param playing 0 for not playing, 1 for playing
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_set_playing(
    ffi.Pointer<aubio_wavetable_t> o,
    int playing,
  ) {
    return _aubio_wavetable_set_playing(
      o,
      playing,
    );
  }

  late final _aubio_wavetable_set_playingPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_wavetable_t>,
              uint_t)>>('aubio_wavetable_set_playing');
  late final _aubio_wavetable_set_playing = _aubio_wavetable_set_playingPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>, int)>();

  /// play sample from start
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_play(
    ffi.Pointer<aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_play(
      o,
    );
  }

  late final _aubio_wavetable_playPtr = _lookup<
          ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_wavetable_t>)>>(
      'aubio_wavetable_play');
  late final _aubio_wavetable_play = _aubio_wavetable_playPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// stop wavetable
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_stop(
    ffi.Pointer<aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_stop(
      o,
    );
  }

  late final _aubio_wavetable_stopPtr = _lookup<
          ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_wavetable_t>)>>(
      'aubio_wavetable_stop');
  late final _aubio_wavetable_stop = _aubio_wavetable_stopPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// set wavetable frequency
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param freq new frequency value for the wavetable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_set_freq(
    ffi.Pointer<aubio_wavetable_t> o,
    double freq,
  ) {
    return _aubio_wavetable_set_freq(
      o,
      freq,
    );
  }

  late final _aubio_wavetable_set_freqPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_wavetable_t>,
              smpl_t)>>('aubio_wavetable_set_freq');
  late final _aubio_wavetable_set_freq = _aubio_wavetable_set_freqPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>, double)>();

  /// get wavetable frequency
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return current frequency, in Hz
  double aubio_wavetable_get_freq(
    ffi.Pointer<aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_get_freq(
      o,
    );
  }

  late final _aubio_wavetable_get_freqPtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_wavetable_t>)>>(
      'aubio_wavetable_get_freq');
  late final _aubio_wavetable_get_freq = _aubio_wavetable_get_freqPtr
      .asFunction<double Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// set wavetable amplitude
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param amp new amplitude value for the wavetable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_set_amp(
    ffi.Pointer<aubio_wavetable_t> o,
    double amp,
  ) {
    return _aubio_wavetable_set_amp(
      o,
      amp,
    );
  }

  late final _aubio_wavetable_set_ampPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_wavetable_t>,
              smpl_t)>>('aubio_wavetable_set_amp');
  late final _aubio_wavetable_set_amp = _aubio_wavetable_set_ampPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>, double)>();

  /// get wavetable amplitude
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return current amplitude
  double aubio_wavetable_get_amp(
    ffi.Pointer<aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_get_amp(
      o,
    );
  }

  late final _aubio_wavetable_get_ampPtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_wavetable_t>)>>(
      'aubio_wavetable_get_amp');
  late final _aubio_wavetable_get_amp = _aubio_wavetable_get_ampPtr
      .asFunction<double Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// destroy aubio_wavetable_t object
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  void del_aubio_wavetable(
    ffi.Pointer<aubio_wavetable_t> o,
  ) {
    return _del_aubio_wavetable(
      o,
    );
  }

  late final _del_aubio_wavetablePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_wavetable_t>)>>(
      'del_aubio_wavetable');
  late final _del_aubio_wavetable = _del_aubio_wavetablePtr
      .asFunction<void Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// create new parameter object
  ///
  /// \param min_value the minimum value of the new parameter
  /// \param max_value the maximum value of the new parameter
  /// \param steps the number of steps to interpolate from the old value to the target value
  ///
  /// \return the newly created ::aubio_parameter_t
  ffi.Pointer<aubio_parameter_t> new_aubio_parameter(
    double min_value,
    double max_value,
    int steps,
  ) {
    return _new_aubio_parameter(
      min_value,
      max_value,
      steps,
    );
  }

  late final _new_aubio_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_parameter_t> Function(
              smpl_t, smpl_t, uint_t)>>('new_aubio_parameter');
  late final _new_aubio_parameter = _new_aubio_parameterPtr.asFunction<
      ffi.Pointer<aubio_parameter_t> Function(double, double, int)>();

  /// set target value of the parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param value new target value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_target_value(
    ffi.Pointer<aubio_parameter_t> param,
    double value,
  ) {
    return _aubio_parameter_set_target_value(
      param,
      value,
    );
  }

  late final _aubio_parameter_set_target_valuePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>,
              smpl_t)>>('aubio_parameter_set_target_value');
  late final _aubio_parameter_set_target_value =
      _aubio_parameter_set_target_valuePtr
          .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, double)>();

  /// get next parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return new interpolated parameter value
  double aubio_parameter_get_next_value(
    ffi.Pointer<aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_next_value(
      param,
    );
  }

  late final _aubio_parameter_get_next_valuePtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_parameter_t>)>>(
      'aubio_parameter_get_next_value');
  late final _aubio_parameter_get_next_value =
      _aubio_parameter_get_next_valuePtr
          .asFunction<double Function(ffi.Pointer<aubio_parameter_t>)>();

  /// get current parameter value, without interpolation
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return current value
  double aubio_parameter_get_current_value(
    ffi.Pointer<aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_current_value(
      param,
    );
  }

  late final _aubio_parameter_get_current_valuePtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_parameter_t>)>>(
      'aubio_parameter_get_current_value');
  late final _aubio_parameter_get_current_value =
      _aubio_parameter_get_current_valuePtr
          .asFunction<double Function(ffi.Pointer<aubio_parameter_t>)>();

  /// set current parameter value, skipping interpolation
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param value new parameter value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_current_value(
    ffi.Pointer<aubio_parameter_t> param,
    double value,
  ) {
    return _aubio_parameter_set_current_value(
      param,
      value,
    );
  }

  late final _aubio_parameter_set_current_valuePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>,
              smpl_t)>>('aubio_parameter_set_current_value');
  late final _aubio_parameter_set_current_value =
      _aubio_parameter_set_current_valuePtr
          .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, double)>();

  /// set number of steps used for interpolation
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param steps new number of steps
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_steps(
    ffi.Pointer<aubio_parameter_t> param,
    int steps,
  ) {
    return _aubio_parameter_set_steps(
      param,
      steps,
    );
  }

  late final _aubio_parameter_set_stepsPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>,
              uint_t)>>('aubio_parameter_set_steps');
  late final _aubio_parameter_set_steps = _aubio_parameter_set_stepsPtr
      .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, int)>();

  /// get number of steps of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return number of steps
  int aubio_parameter_get_steps(
    ffi.Pointer<aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_steps(
      param,
    );
  }

  late final _aubio_parameter_get_stepsPtr = _lookup<
          ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_parameter_t>)>>(
      'aubio_parameter_get_steps');
  late final _aubio_parameter_get_steps = _aubio_parameter_get_stepsPtr
      .asFunction<int Function(ffi.Pointer<aubio_parameter_t>)>();

  /// set minimum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param min_value new minimum value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_min_value(
    ffi.Pointer<aubio_parameter_t> param,
    double min_value,
  ) {
    return _aubio_parameter_set_min_value(
      param,
      min_value,
    );
  }

  late final _aubio_parameter_set_min_valuePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>,
              smpl_t)>>('aubio_parameter_set_min_value');
  late final _aubio_parameter_set_min_value = _aubio_parameter_set_min_valuePtr
      .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, double)>();

  /// get minimum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return minimum value
  double aubio_parameter_get_min_value(
    ffi.Pointer<aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_min_value(
      param,
    );
  }

  late final _aubio_parameter_get_min_valuePtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_parameter_t>)>>(
      'aubio_parameter_get_min_value');
  late final _aubio_parameter_get_min_value = _aubio_parameter_get_min_valuePtr
      .asFunction<double Function(ffi.Pointer<aubio_parameter_t>)>();

  /// set maximum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param max_value new maximum value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_max_value(
    ffi.Pointer<aubio_parameter_t> param,
    double max_value,
  ) {
    return _aubio_parameter_set_max_value(
      param,
      max_value,
    );
  }

  late final _aubio_parameter_set_max_valuePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>,
              smpl_t)>>('aubio_parameter_set_max_value');
  late final _aubio_parameter_set_max_value = _aubio_parameter_set_max_valuePtr
      .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, double)>();

  /// get maximum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return maximum value
  double aubio_parameter_get_max_value(
    ffi.Pointer<aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_max_value(
      param,
    );
  }

  late final _aubio_parameter_get_max_valuePtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_parameter_t>)>>(
      'aubio_parameter_get_max_value');
  late final _aubio_parameter_get_max_value = _aubio_parameter_get_max_valuePtr
      .asFunction<double Function(ffi.Pointer<aubio_parameter_t>)>();

  /// destroy ::aubio_parameter_t object
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  void del_aubio_parameter(
    ffi.Pointer<aubio_parameter_t> param,
  ) {
    return _del_aubio_parameter(
      param,
    );
  }

  late final _del_aubio_parameterPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_parameter_t>)>>(
      'del_aubio_parameter');
  late final _del_aubio_parameter = _del_aubio_parameterPtr
      .asFunction<void Function(ffi.Pointer<aubio_parameter_t>)>();

  /// Set logging function for all levels
  ///
  /// \param fun the function to be used to log, of type ::aubio_log_function_t
  /// \param data optional closure to be passed to the function (can be NULL if
  /// nothing to pass)
  void aubio_log_set_function(
    aubio_log_function_t fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _aubio_log_set_function(
      fun,
      data,
    );
  }

  late final _aubio_log_set_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(aubio_log_function_t,
              ffi.Pointer<ffi.Void>)>>('aubio_log_set_function');
  late final _aubio_log_set_function = _aubio_log_set_functionPtr
      .asFunction<void Function(aubio_log_function_t, ffi.Pointer<ffi.Void>)>();

  /// Set logging function for a given level
  ///
  /// \param level the level for which to set the logging function
  /// \param fun the function to be used to log, of type ::aubio_log_function_t
  /// \param data optional closure to be passed to the function (can be NULL if
  /// nothing to pass)
  aubio_log_function_t aubio_log_set_level_function(
    int level,
    aubio_log_function_t fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _aubio_log_set_level_function(
      level,
      fun,
      data,
    );
  }

  late final _aubio_log_set_level_functionPtr = _lookup<
      ffi.NativeFunction<
          aubio_log_function_t Function(sint_t, aubio_log_function_t,
              ffi.Pointer<ffi.Void>)>>('aubio_log_set_level_function');
  late final _aubio_log_set_level_function =
      _aubio_log_set_level_functionPtr.asFunction<
          aubio_log_function_t Function(
              int, aubio_log_function_t, ffi.Pointer<ffi.Void>)>();

  /// Reset all logging functions to the default one
  ///
  /// After calling this function, the default logging function will be used to
  /// print error, warning, normal, and debug messages to `stdout` or `stderr`.
  void aubio_log_reset() {
    return _aubio_log_reset();
  }

  late final _aubio_log_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('aubio_log_reset');
  late final _aubio_log_reset =
      _aubio_log_resetPtr.asFunction<void Function()>();

  /// compute the mean of a vector
  ///
  /// \param s vector to compute mean from
  /// \return the mean of `v`
  double fvec_mean(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_mean(
      s,
    );
  }

  late final _fvec_meanPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
          'fvec_mean');
  late final _fvec_mean =
      _fvec_meanPtr.asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// find the max of a vector
  ///
  /// \param s vector to get the max from
  ///
  /// \return the value of the minimum of v
  double fvec_max(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_max(
      s,
    );
  }

  late final _fvec_maxPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
          'fvec_max');
  late final _fvec_max =
      _fvec_maxPtr.asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// find the min of a vector
  ///
  /// \param s vector to get the min from
  ///
  /// \return the value of the maximum of v
  double fvec_min(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_min(
      s,
    );
  }

  late final _fvec_minPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
          'fvec_min');
  late final _fvec_min =
      _fvec_minPtr.asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// find the index of the min of a vector
  ///
  /// \param s vector to get the index from
  ///
  /// \return the index of the minimum element of v
  int fvec_min_elem(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_min_elem(
      s,
    );
  }

  late final _fvec_min_elemPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<fvec_t>)>>(
          'fvec_min_elem');
  late final _fvec_min_elem =
      _fvec_min_elemPtr.asFunction<int Function(ffi.Pointer<fvec_t>)>();

  /// find the index of the max of a vector
  ///
  /// \param s vector to get the index from
  ///
  /// \return the index of the maximum element of v
  int fvec_max_elem(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_max_elem(
      s,
    );
  }

  late final _fvec_max_elemPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<fvec_t>)>>(
          'fvec_max_elem');
  late final _fvec_max_elem =
      _fvec_max_elemPtr.asFunction<int Function(ffi.Pointer<fvec_t>)>();

  /// swap the left and right halves of a vector
  ///
  /// This function swaps the left part of the signal with the right part of the
  /// signal. Therefore
  ///
  /// \f$ a[0], a[1], ..., a[\frac{N}{2}], a[\frac{N}{2}+1], ..., a[N-1], a[N] \f$
  ///
  /// becomes
  ///
  /// \f$ a[\frac{N}{2}+1], ..., a[N-1], a[N], a[0], a[1], ..., a[\frac{N}{2}] \f$
  ///
  /// This operation, known as 'fftshift' in the Matlab Signal Processing Toolbox,
  /// can be used before computing the FFT to simplify the phase relationship of the
  /// resulting spectrum. See Amalia de Götzen's paper referred to above.
  void fvec_shift(
    ffi.Pointer<fvec_t> v,
  ) {
    return _fvec_shift(
      v,
    );
  }

  late final _fvec_shiftPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_shift');
  late final _fvec_shift =
      _fvec_shiftPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// swap the left and right halves of a vector
  ///
  /// This function swaps the left part of the signal with the right part of the
  /// signal. Therefore
  ///
  /// \f$ a[0], a[1], ..., a[\frac{N}{2}], a[\frac{N}{2}+1], ..., a[N-1], a[N] \f$
  ///
  /// becomes
  ///
  /// \f$ a[\frac{N}{2}+1], ..., a[N-1], a[N], a[0], a[1], ..., a[\frac{N}{2}] \f$
  ///
  /// This operation, known as 'ifftshift' in the Matlab Signal Processing Toolbox,
  /// can be used after computing the inverse FFT to simplify the phase relationship
  /// of the resulting spectrum. See Amalia de Götzen's paper referred to above.
  void fvec_ishift(
    ffi.Pointer<fvec_t> v,
  ) {
    return _fvec_ishift(
      v,
    );
  }

  late final _fvec_ishiftPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_ishift');
  late final _fvec_ishift =
      _fvec_ishiftPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// push a new element to the end of a vector, erasing the first element and
  /// sliding all others
  ///
  /// \param in vector to push to
  /// \param new_elem new_element to add at the end of the vector
  ///
  /// In numpy words, this is equivalent to: in = np.concatenate([in, [new_elem]])[1:]
  void fvec_push(
    ffi.Pointer<fvec_t> in1,
    double new_elem,
  ) {
    return _fvec_push(
      in1,
      new_elem,
    );
  }

  late final _fvec_pushPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>>(
      'fvec_push');
  late final _fvec_push =
      _fvec_pushPtr.asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// compute the sum of all elements of a vector
  ///
  /// \param v vector to compute the sum of
  ///
  /// \return the sum of v
  double fvec_sum(
    ffi.Pointer<fvec_t> v,
  ) {
    return _fvec_sum(
      v,
    );
  }

  late final _fvec_sumPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
          'fvec_sum');
  late final _fvec_sum =
      _fvec_sumPtr.asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// compute the High Frequency Content of a vector
  ///
  /// The High Frequency Content is defined as \f$ \sum_0^{N-1} (k+1) v[k] \f$.
  ///
  /// \param v vector to get the energy from
  ///
  /// \return the HFC of v
  double fvec_local_hfc(
    ffi.Pointer<fvec_t> v,
  ) {
    return _fvec_local_hfc(
      v,
    );
  }

  late final _fvec_local_hfcPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
          'fvec_local_hfc');
  late final _fvec_local_hfc =
      _fvec_local_hfcPtr.asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// computes the p-norm of a vector
  ///
  /// Computes the p-norm of a vector for \f$ p = \alpha \f$
  ///
  /// \f$ L^p = ||x||_p = (|x_1|^p + |x_2|^p + ... + |x_n|^p ) ^ \frac{1}{p} \f$
  ///
  /// If p = 1, the result is the Manhattan distance.
  ///
  /// If p = 2, the result is the Euclidean distance.
  ///
  /// As p tends towards large values, \f$ L^p \f$ tends towards the maximum of the
  /// input vector.
  ///
  /// References:
  ///
  /// - <a href="http://en.wikipedia.org/wiki/Lp_space">\f$L^p\f$ space</a> on
  /// Wikipedia
  ///
  /// \param v vector to compute norm from
  /// \param p order of the computed norm
  ///
  /// \return the p-norm of v
  double fvec_alpha_norm(
    ffi.Pointer<fvec_t> v,
    double p,
  ) {
    return _fvec_alpha_norm(
      v,
      p,
    );
  }

  late final _fvec_alpha_normPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>, smpl_t)>>(
          'fvec_alpha_norm');
  late final _fvec_alpha_norm = _fvec_alpha_normPtr
      .asFunction<double Function(ffi.Pointer<fvec_t>, double)>();

  /// alpha normalisation
  ///
  /// This function divides all elements of a vector by the p-norm as computed by
  /// fvec_alpha_norm().
  ///
  /// \param v vector to compute norm from
  /// \param p order of the computed norm
  void fvec_alpha_normalise(
    ffi.Pointer<fvec_t> v,
    double p,
  ) {
    return _fvec_alpha_normalise(
      v,
      p,
    );
  }

  late final _fvec_alpha_normalisePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>>(
      'fvec_alpha_normalise');
  late final _fvec_alpha_normalise = _fvec_alpha_normalisePtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// add a constant to each elements of a vector
  ///
  /// \param v vector to add constant to
  /// \param c constant to add to v
  void fvec_add(
    ffi.Pointer<fvec_t> v,
    double c,
  ) {
    return _fvec_add(
      v,
      c,
    );
  }

  late final _fvec_addPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>>(
      'fvec_add');
  late final _fvec_add =
      _fvec_addPtr.asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// multiply each elements of a vector by a scalar
  ///
  /// \param v vector to add constant to
  /// \param s constant to scale v with
  void fvec_mul(
    ffi.Pointer<fvec_t> v,
    double s,
  ) {
    return _fvec_mul(
      v,
      s,
    );
  }

  late final _fvec_mulPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>>(
      'fvec_mul');
  late final _fvec_mul =
      _fvec_mulPtr.asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// remove the minimum value of the vector to each elements
  ///
  /// \param v vector to remove minimum from
  void fvec_min_removal(
    ffi.Pointer<fvec_t> v,
  ) {
    return _fvec_min_removal(
      v,
    );
  }

  late final _fvec_min_removalPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
          'fvec_min_removal');
  late final _fvec_min_removal =
      _fvec_min_removalPtr.asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute moving median threshold of a vector
  ///
  /// This function computes the moving median threshold value of at the given
  /// position of a vector, taking the median among post elements before and up to
  /// pre elements after pos.
  ///
  /// \param v input vector
  /// \param tmp temporary vector of length post+1+pre
  /// \param post length of causal part to take before pos
  /// \param pre length of anti-causal part to take after pos
  /// \param pos index to compute threshold for
  ///
  /// \return moving median threshold value
  double fvec_moving_thres(
    ffi.Pointer<fvec_t> v,
    ffi.Pointer<fvec_t> tmp,
    int post,
    int pre,
    int pos,
  ) {
    return _fvec_moving_thres(
      v,
      tmp,
      post,
      pre,
      pos,
    );
  }

  late final _fvec_moving_thresPtr = _lookup<
      ffi.NativeFunction<
          smpl_t Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>, uint_t,
              uint_t, uint_t)>>('fvec_moving_thres');
  late final _fvec_moving_thres = _fvec_moving_thresPtr.asFunction<
      double Function(
          ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>, int, int, int)>();

  /// apply adaptive threshold to a vector
  ///
  /// For each points at position p of an input vector, this function remove the
  /// moving median threshold computed at p.
  ///
  /// \param v input vector
  /// \param tmp temporary vector of length post+1+pre
  /// \param post length of causal part to take before pos
  /// \param pre length of anti-causal part to take after pos
  void fvec_adapt_thres(
    ffi.Pointer<fvec_t> v,
    ffi.Pointer<fvec_t> tmp,
    int post,
    int pre,
  ) {
    return _fvec_adapt_thres(
      v,
      tmp,
      post,
      pre,
    );
  }

  late final _fvec_adapt_thresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>, uint_t,
              uint_t)>>('fvec_adapt_thres');
  late final _fvec_adapt_thres = _fvec_adapt_thresPtr.asFunction<
      void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>, int, int)>();

  /// returns the median of a vector
  ///
  /// The QuickSelect routine is based on the algorithm described in "Numerical
  /// recipes in C", Second Edition, Cambridge University Press, 1992, Section 8.5,
  /// ISBN 0-521-43108-5
  ///
  /// This implementation of the QuickSelect routine is based on Nicolas
  /// Devillard's implementation, available at http://ndevilla.free.fr/median/median/
  /// and in the Public Domain.
  ///
  /// \param v vector to get median from
  ///
  /// \return the median of v
  double fvec_median(
    ffi.Pointer<fvec_t> v,
  ) {
    return _fvec_median(
      v,
    );
  }

  late final _fvec_medianPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
          'fvec_median');
  late final _fvec_median =
      _fvec_medianPtr.asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// finds exact peak index by quadratic interpolation
  ///
  /// See [Quadratic Interpolation of Spectral
  /// Peaks](https://ccrma.stanford.edu/~jos/sasp/Quadratic_Peak_Interpolation.html),
  /// by Julius O. Smith III
  ///
  /// \f$ p_{frac} = \frac{1}{2} \frac {x[p-1] - x[p+1]} {x[p-1] - 2 x[p] + x[p+1]} \in [ -.5, .5] \f$
  ///
  /// \param x vector to get the interpolated peak position from
  /// \param p index of the peak in vector `x`
  /// \return \f$ p + p_{frac} \f$ exact peak position of interpolated maximum or minimum
  double fvec_quadratic_peak_pos(
    ffi.Pointer<fvec_t> x,
    int p,
  ) {
    return _fvec_quadratic_peak_pos(
      x,
      p,
    );
  }

  late final _fvec_quadratic_peak_posPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>, uint_t)>>(
          'fvec_quadratic_peak_pos');
  late final _fvec_quadratic_peak_pos = _fvec_quadratic_peak_posPtr
      .asFunction<double Function(ffi.Pointer<fvec_t>, int)>();

  /// finds magnitude of peak by quadratic interpolation
  ///
  /// See [Quadratic Interpolation of Spectral
  /// Peaks](https://ccrma.stanford.edu/~jos/sasp/Quadratic_Peak_Interpolation.html),
  /// by Julius O. Smith III
  ///
  /// \param x vector to get the magnitude of the interpolated peak position from
  /// \param p index of the peak in vector `x`
  /// \return magnitude of interpolated peak
  double fvec_quadratic_peak_mag(
    ffi.Pointer<fvec_t> x,
    double p,
  ) {
    return _fvec_quadratic_peak_mag(
      x,
      p,
    );
  }

  late final _fvec_quadratic_peak_magPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>, smpl_t)>>(
          'fvec_quadratic_peak_mag');
  late final _fvec_quadratic_peak_mag = _fvec_quadratic_peak_magPtr
      .asFunction<double Function(ffi.Pointer<fvec_t>, double)>();

  /// Quadratic interpolation using Lagrange polynomial.
  ///
  /// Inspired from ``Comparison of interpolation algorithms in real-time sound
  /// processing'', Vladimir Arnost,
  ///
  /// \param s0,s1,s2 are 3 consecutive samples of a curve
  /// \param pf is the floating point index [0;2]
  ///
  /// \return \f$ s0 + (pf/2.)*((pf-3.)*s0-2.*(pf-2.)*s1+(pf-1.)*s2); \f$
  double aubio_quadfrac(
    double s0,
    double s1,
    double s2,
    double pf,
  ) {
    return _aubio_quadfrac(
      s0,
      s1,
      s2,
      pf,
    );
  }

  late final _aubio_quadfracPtr = _lookup<
          ffi.NativeFunction<smpl_t Function(smpl_t, smpl_t, smpl_t, smpl_t)>>(
      'aubio_quadfrac');
  late final _aubio_quadfrac = _aubio_quadfracPtr
      .asFunction<double Function(double, double, double, double)>();

  /// return 1 if v[p] is a peak and positive, 0 otherwise
  ///
  /// This function returns 1 if a peak is found at index p in the vector v. The
  /// peak is defined as follows:
  ///
  /// - v[p] is positive
  /// - v[p-1] < v[p]
  /// - v[p] > v[p+1]
  ///
  /// \param v input vector
  /// \param p position of supposed for peak
  ///
  /// \return 1 if a peak is found, 0 otherwise
  int fvec_peakpick(
    ffi.Pointer<fvec_t> v,
    int p,
  ) {
    return _fvec_peakpick(
      v,
      p,
    );
  }

  late final _fvec_peakpickPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<fvec_t>, uint_t)>>(
          'fvec_peakpick');
  late final _fvec_peakpick =
      _fvec_peakpickPtr.asFunction<int Function(ffi.Pointer<fvec_t>, int)>();

  /// return 1 if a is a power of 2, 0 otherwise
  int aubio_is_power_of_two(
    int a,
  ) {
    return _aubio_is_power_of_two(
      a,
    );
  }

  late final _aubio_is_power_of_twoPtr =
      _lookup<ffi.NativeFunction<uint_t Function(uint_t)>>(
          'aubio_is_power_of_two');
  late final _aubio_is_power_of_two =
      _aubio_is_power_of_twoPtr.asFunction<int Function(int)>();

  /// return the next power of power of 2 greater than a
  int aubio_next_power_of_two(
    int a,
  ) {
    return _aubio_next_power_of_two(
      a,
    );
  }

  late final _aubio_next_power_of_twoPtr =
      _lookup<ffi.NativeFunction<uint_t Function(uint_t)>>(
          'aubio_next_power_of_two');
  late final _aubio_next_power_of_two =
      _aubio_next_power_of_twoPtr.asFunction<int Function(int)>();

  /// return the log2 factor of the given power of 2 value a
  int aubio_power_of_two_order(
    int a,
  ) {
    return _aubio_power_of_two_order(
      a,
    );
  }

  late final _aubio_power_of_two_orderPtr =
      _lookup<ffi.NativeFunction<uint_t Function(uint_t)>>(
          'aubio_power_of_two_order');
  late final _aubio_power_of_two_order =
      _aubio_power_of_two_orderPtr.asFunction<int Function(int)>();

  /// compute normalised autocorrelation function
  ///
  /// \param input vector to compute autocorrelation from
  /// \param output vector to store autocorrelation function to
  void aubio_autocorr(
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_autocorr(
      input,
      output,
    );
  }

  late final _aubio_autocorrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>>('aubio_autocorr');
  late final _aubio_autocorr = _aubio_autocorrPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>();

  /// internal logging function, defined in utils/log.c
  int aubio_log(
    int level,
    ffi.Pointer<char_t> fmt,
  ) {
    return _aubio_log(
      level,
      fmt,
    );
  }

  late final _aubio_logPtr =
      _lookup<ffi.NativeFunction<uint_t Function(sint_t, ffi.Pointer<char_t>)>>(
          'aubio_log');
  late final _aubio_log =
      _aubio_logPtr.asFunction<int Function(int, ffi.Pointer<char_t>)>();

  /// creation of the pitch detection object
  ///
  /// \param buf_size size of the input buffer to analyse
  ffi.Pointer<aubio_pitchyin_t> new_aubio_pitchyin(
    int buf_size,
  ) {
    return _new_aubio_pitchyin(
      buf_size,
    );
  }

  late final _new_aubio_pitchyinPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<aubio_pitchyin_t> Function(uint_t)>>(
      'new_aubio_pitchyin');
  late final _new_aubio_pitchyin = _new_aubio_pitchyinPtr
      .asFunction<ffi.Pointer<aubio_pitchyin_t> Function(int)>();

  /// deletion of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitchyin()
  void del_aubio_pitchyin(
    ffi.Pointer<aubio_pitchyin_t> o,
  ) {
    return _del_aubio_pitchyin(
      o,
    );
  }

  late final _del_aubio_pitchyinPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_pitchyin_t>)>>(
      'del_aubio_pitchyin');
  late final _del_aubio_pitchyin = _del_aubio_pitchyinPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitchyin_t>)>();

  /// execute pitch detection an input buffer
  ///
  /// \param o pitch detection object as returned by new_aubio_pitchyin()
  /// \param samples_in input signal vector (length as specified at creation time)
  /// \param cands_out pitch period candidates, in samples
  void aubio_pitchyin_do(
    ffi.Pointer<aubio_pitchyin_t> o,
    ffi.Pointer<fvec_t> samples_in,
    ffi.Pointer<fvec_t> cands_out,
  ) {
    return _aubio_pitchyin_do(
      o,
      samples_in,
      cands_out,
    );
  }

  late final _aubio_pitchyin_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_pitchyin_t>, ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pitchyin_do');
  late final _aubio_pitchyin_do = _aubio_pitchyin_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pitchyin_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// set tolerance parameter for YIN algorithm
  ///
  /// \param o YIN pitch detection object
  /// \param tol tolerance parameter for minima selection [default 0.15]
  int aubio_pitchyin_set_tolerance(
    ffi.Pointer<aubio_pitchyin_t> o,
    double tol,
  ) {
    return _aubio_pitchyin_set_tolerance(
      o,
      tol,
    );
  }

  late final _aubio_pitchyin_set_tolerancePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pitchyin_t>,
              smpl_t)>>('aubio_pitchyin_set_tolerance');
  late final _aubio_pitchyin_set_tolerance = _aubio_pitchyin_set_tolerancePtr
      .asFunction<int Function(ffi.Pointer<aubio_pitchyin_t>, double)>();

  /// get tolerance parameter for YIN algorithm
  ///
  /// \param o YIN pitch detection object
  /// \return tolerance parameter for minima selection [default 0.15]
  double aubio_pitchyin_get_tolerance(
    ffi.Pointer<aubio_pitchyin_t> o,
  ) {
    return _aubio_pitchyin_get_tolerance(
      o,
    );
  }

  late final _aubio_pitchyin_get_tolerancePtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchyin_t>)>>(
      'aubio_pitchyin_get_tolerance');
  late final _aubio_pitchyin_get_tolerance = _aubio_pitchyin_get_tolerancePtr
      .asFunction<double Function(ffi.Pointer<aubio_pitchyin_t>)>();

  /// get current confidence of YIN algorithm
  ///
  /// \param o YIN pitch detection object
  /// \return confidence parameter
  double aubio_pitchyin_get_confidence(
    ffi.Pointer<aubio_pitchyin_t> o,
  ) {
    return _aubio_pitchyin_get_confidence(
      o,
    );
  }

  late final _aubio_pitchyin_get_confidencePtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchyin_t>)>>(
      'aubio_pitchyin_get_confidence');
  late final _aubio_pitchyin_get_confidence = _aubio_pitchyin_get_confidencePtr
      .asFunction<double Function(ffi.Pointer<aubio_pitchyin_t>)>();

  /// execute pitch detection on an input buffer
  ///
  /// \param p pitch detection object as returned by new_aubio_pitchfcomb
  /// \param input input signal window (length as specified at creation time)
  /// \param output pitch candidates in bins
  void aubio_pitchfcomb_do(
    ffi.Pointer<aubio_pitchfcomb_t> p,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_pitchfcomb_do(
      p,
      input,
      output,
    );
  }

  late final _aubio_pitchfcomb_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchfcomb_t>,
              ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pitchfcomb_do');
  late final _aubio_pitchfcomb_do = _aubio_pitchfcomb_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pitchfcomb_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// creation of the pitch detection object
  ///
  /// \param buf_size size of the input buffer to analyse
  /// \param hop_size step size between two consecutive analysis instant
  ffi.Pointer<aubio_pitchfcomb_t> new_aubio_pitchfcomb(
    int buf_size,
    int hop_size,
  ) {
    return _new_aubio_pitchfcomb(
      buf_size,
      hop_size,
    );
  }

  late final _new_aubio_pitchfcombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_pitchfcomb_t> Function(
              uint_t, uint_t)>>('new_aubio_pitchfcomb');
  late final _new_aubio_pitchfcomb = _new_aubio_pitchfcombPtr
      .asFunction<ffi.Pointer<aubio_pitchfcomb_t> Function(int, int)>();

  /// deletion of the pitch detection object
  ///
  /// \param p pitch detection object as returned by new_aubio_pitchfcomb
  void del_aubio_pitchfcomb(
    ffi.Pointer<aubio_pitchfcomb_t> p,
  ) {
    return _del_aubio_pitchfcomb(
      p,
    );
  }

  late final _del_aubio_pitchfcombPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_pitchfcomb_t>)>>(
      'del_aubio_pitchfcomb');
  late final _del_aubio_pitchfcomb = _del_aubio_pitchfcombPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitchfcomb_t>)>();

  /// execute pitch detection on an input buffer
  ///
  /// \param o pitch detection object as returned by new_aubio_pitchyinfft
  /// \param samples_in input signal vector (length as specified at creation time)
  /// \param cands_out pitch period candidates, in samples
  void aubio_pitchyinfft_do(
    ffi.Pointer<aubio_pitchyinfft_t> o,
    ffi.Pointer<fvec_t> samples_in,
    ffi.Pointer<fvec_t> cands_out,
  ) {
    return _aubio_pitchyinfft_do(
      o,
      samples_in,
      cands_out,
    );
  }

  late final _aubio_pitchyinfft_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchyinfft_t>,
              ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pitchyinfft_do');
  late final _aubio_pitchyinfft_do = _aubio_pitchyinfft_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pitchyinfft_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// creation of the pitch detection object
  ///
  /// \param samplerate samplerate of the input signal
  /// \param buf_size size of the input buffer to analyse
  ffi.Pointer<aubio_pitchyinfft_t> new_aubio_pitchyinfft(
    int samplerate,
    int buf_size,
  ) {
    return _new_aubio_pitchyinfft(
      samplerate,
      buf_size,
    );
  }

  late final _new_aubio_pitchyinfftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_pitchyinfft_t> Function(
              uint_t, uint_t)>>('new_aubio_pitchyinfft');
  late final _new_aubio_pitchyinfft = _new_aubio_pitchyinfftPtr
      .asFunction<ffi.Pointer<aubio_pitchyinfft_t> Function(int, int)>();

  /// deletion of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitchyinfft()
  void del_aubio_pitchyinfft(
    ffi.Pointer<aubio_pitchyinfft_t> o,
  ) {
    return _del_aubio_pitchyinfft(
      o,
    );
  }

  late final _del_aubio_pitchyinfftPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_pitchyinfft_t>)>>(
      'del_aubio_pitchyinfft');
  late final _del_aubio_pitchyinfft = _del_aubio_pitchyinfftPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitchyinfft_t>)>();

  /// get tolerance parameter for YIN algorithm
  ///
  /// \param o YIN pitch detection object
  ///
  /// \return tolerance parameter for minima selection [default 0.15]
  double aubio_pitchyinfft_get_tolerance(
    ffi.Pointer<aubio_pitchyinfft_t> o,
  ) {
    return _aubio_pitchyinfft_get_tolerance(
      o,
    );
  }

  late final _aubio_pitchyinfft_get_tolerancePtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchyinfft_t>)>>(
      'aubio_pitchyinfft_get_tolerance');
  late final _aubio_pitchyinfft_get_tolerance =
      _aubio_pitchyinfft_get_tolerancePtr
          .asFunction<double Function(ffi.Pointer<aubio_pitchyinfft_t>)>();

  /// set tolerance parameter for YIN algorithm
  ///
  /// \param o YIN pitch detection object
  /// \param tol tolerance parameter for minima selection [default 0.15]
  int aubio_pitchyinfft_set_tolerance(
    ffi.Pointer<aubio_pitchyinfft_t> o,
    double tol,
  ) {
    return _aubio_pitchyinfft_set_tolerance(
      o,
      tol,
    );
  }

  late final _aubio_pitchyinfft_set_tolerancePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pitchyinfft_t>,
              smpl_t)>>('aubio_pitchyinfft_set_tolerance');
  late final _aubio_pitchyinfft_set_tolerance =
      _aubio_pitchyinfft_set_tolerancePtr
          .asFunction<int Function(ffi.Pointer<aubio_pitchyinfft_t>, double)>();

  /// get current confidence of YIN algorithm
  ///
  /// \param o YIN pitch detection object
  /// \return confidence parameter
  double aubio_pitchyinfft_get_confidence(
    ffi.Pointer<aubio_pitchyinfft_t> o,
  ) {
    return _aubio_pitchyinfft_get_confidence(
      o,
    );
  }

  late final _aubio_pitchyinfft_get_confidencePtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchyinfft_t>)>>(
      'aubio_pitchyinfft_get_confidence');
  late final _aubio_pitchyinfft_get_confidence =
      _aubio_pitchyinfft_get_confidencePtr
          .asFunction<double Function(ffi.Pointer<aubio_pitchyinfft_t>)>();

  /// execute pitch detection on an input buffer
  ///
  /// \param o pitch detection object as returned by new_aubio_pitchspecacf
  /// \param samples_in input signal vector (length as specified at creation time)
  /// \param cands_out pitch period candidates, in samples
  void aubio_pitchspecacf_do(
    ffi.Pointer<aubio_pitchspecacf_t> o,
    ffi.Pointer<fvec_t> samples_in,
    ffi.Pointer<fvec_t> cands_out,
  ) {
    return _aubio_pitchspecacf_do(
      o,
      samples_in,
      cands_out,
    );
  }

  late final _aubio_pitchspecacf_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchspecacf_t>,
              ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pitchspecacf_do');
  late final _aubio_pitchspecacf_do = _aubio_pitchspecacf_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pitchspecacf_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// creation of the pitch detection object
  ///
  /// \param buf_size size of the input buffer to analyse
  ffi.Pointer<aubio_pitchspecacf_t> new_aubio_pitchspecacf(
    int buf_size,
  ) {
    return _new_aubio_pitchspecacf(
      buf_size,
    );
  }

  late final _new_aubio_pitchspecacfPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<aubio_pitchspecacf_t> Function(uint_t)>>(
      'new_aubio_pitchspecacf');
  late final _new_aubio_pitchspecacf = _new_aubio_pitchspecacfPtr
      .asFunction<ffi.Pointer<aubio_pitchspecacf_t> Function(int)>();

  /// deletion of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitchspecacf()
  void del_aubio_pitchspecacf(
    ffi.Pointer<aubio_pitchspecacf_t> o,
  ) {
    return _del_aubio_pitchspecacf(
      o,
    );
  }

  late final _del_aubio_pitchspecacfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchspecacf_t>)>>('del_aubio_pitchspecacf');
  late final _del_aubio_pitchspecacf = _del_aubio_pitchspecacfPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitchspecacf_t>)>();

  /// get tolerance parameter for `specacf` pitch detection object
  ///
  /// \param o pitch detection object
  ///
  /// \return tolerance parameter for minima selection [default 1.]
  double aubio_pitchspecacf_get_tolerance(
    ffi.Pointer<aubio_pitchspecacf_t> o,
  ) {
    return _aubio_pitchspecacf_get_tolerance(
      o,
    );
  }

  late final _aubio_pitchspecacf_get_tolerancePtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchspecacf_t>)>>(
      'aubio_pitchspecacf_get_tolerance');
  late final _aubio_pitchspecacf_get_tolerance =
      _aubio_pitchspecacf_get_tolerancePtr
          .asFunction<double Function(ffi.Pointer<aubio_pitchspecacf_t>)>();

  /// set tolerance parameter for `specacf` pitch detection object
  ///
  /// \param o pitch detection object
  /// \param tol tolerance parameter for minima selection [default 1.]
  ///
  /// \return `1` on error, `0` on success
  int aubio_pitchspecacf_set_tolerance(
    ffi.Pointer<aubio_pitchspecacf_t> o,
    double tol,
  ) {
    return _aubio_pitchspecacf_set_tolerance(
      o,
      tol,
    );
  }

  late final _aubio_pitchspecacf_set_tolerancePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pitchspecacf_t>,
              smpl_t)>>('aubio_pitchspecacf_set_tolerance');
  late final _aubio_pitchspecacf_set_tolerance =
      _aubio_pitchspecacf_set_tolerancePtr.asFunction<
          int Function(ffi.Pointer<aubio_pitchspecacf_t>, double)>();

  /// get currenct confidence for `specacf` pitch detection object
  ///
  /// \param o pitch detection object
  /// \return confidence parameter
  double aubio_pitchspecacf_get_confidence(
    ffi.Pointer<aubio_pitchspecacf_t> o,
  ) {
    return _aubio_pitchspecacf_get_confidence(
      o,
    );
  }

  late final _aubio_pitchspecacf_get_confidencePtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchspecacf_t>)>>(
      'aubio_pitchspecacf_get_confidence');
  late final _aubio_pitchspecacf_get_confidence =
      _aubio_pitchspecacf_get_confidencePtr
          .asFunction<double Function(ffi.Pointer<aubio_pitchspecacf_t>)>();

  /// execute pitch detection on an input buffer
  ///
  /// \param p pitch detection object as returned by new_aubio_pitchschmitt
  /// \param samples_in input signal vector (length as specified at creation time)
  /// \param cands_out pitch period estimates, in samples
  void aubio_pitchschmitt_do(
    ffi.Pointer<aubio_pitchschmitt_t> p,
    ffi.Pointer<fvec_t> samples_in,
    ffi.Pointer<fvec_t> cands_out,
  ) {
    return _aubio_pitchschmitt_do(
      p,
      samples_in,
      cands_out,
    );
  }

  late final _aubio_pitchschmitt_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchschmitt_t>,
              ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pitchschmitt_do');
  late final _aubio_pitchschmitt_do = _aubio_pitchschmitt_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pitchschmitt_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// creation of the pitch detection object
  ///
  /// \param buf_size size of the input buffer to analyse
  ffi.Pointer<aubio_pitchschmitt_t> new_aubio_pitchschmitt(
    int buf_size,
  ) {
    return _new_aubio_pitchschmitt(
      buf_size,
    );
  }

  late final _new_aubio_pitchschmittPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<aubio_pitchschmitt_t> Function(uint_t)>>(
      'new_aubio_pitchschmitt');
  late final _new_aubio_pitchschmitt = _new_aubio_pitchschmittPtr
      .asFunction<ffi.Pointer<aubio_pitchschmitt_t> Function(int)>();

  /// deletion of the pitch detection object
  ///
  /// \param p pitch detection object as returned by new_aubio_pitchschmitt
  void del_aubio_pitchschmitt(
    ffi.Pointer<aubio_pitchschmitt_t> p,
  ) {
    return _del_aubio_pitchschmitt(
      p,
    );
  }

  late final _del_aubio_pitchschmittPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchschmitt_t>)>>('del_aubio_pitchschmitt');
  late final _del_aubio_pitchschmitt = _del_aubio_pitchschmittPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitchschmitt_t>)>();

  /// creation of the pitch detection object
  ///
  /// \param buf_size size of the input buffer to analyse
  ffi.Pointer<aubio_pitchyinfast_t> new_aubio_pitchyinfast(
    int buf_size,
  ) {
    return _new_aubio_pitchyinfast(
      buf_size,
    );
  }

  late final _new_aubio_pitchyinfastPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<aubio_pitchyinfast_t> Function(uint_t)>>(
      'new_aubio_pitchyinfast');
  late final _new_aubio_pitchyinfast = _new_aubio_pitchyinfastPtr
      .asFunction<ffi.Pointer<aubio_pitchyinfast_t> Function(int)>();

  /// deletion of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitchyin()
  void del_aubio_pitchyinfast(
    ffi.Pointer<aubio_pitchyinfast_t> o,
  ) {
    return _del_aubio_pitchyinfast(
      o,
    );
  }

  late final _del_aubio_pitchyinfastPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchyinfast_t>)>>('del_aubio_pitchyinfast');
  late final _del_aubio_pitchyinfast = _del_aubio_pitchyinfastPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitchyinfast_t>)>();

  /// execute pitch detection an input buffer
  ///
  /// \param o pitch detection object as returned by new_aubio_pitchyin()
  /// \param samples_in input signal vector (length as specified at creation time)
  /// \param cands_out pitch period candidates, in samples
  void aubio_pitchyinfast_do(
    ffi.Pointer<aubio_pitchyinfast_t> o,
    ffi.Pointer<fvec_t> samples_in,
    ffi.Pointer<fvec_t> cands_out,
  ) {
    return _aubio_pitchyinfast_do(
      o,
      samples_in,
      cands_out,
    );
  }

  late final _aubio_pitchyinfast_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchyinfast_t>,
              ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pitchyinfast_do');
  late final _aubio_pitchyinfast_do = _aubio_pitchyinfast_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pitchyinfast_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// set tolerance parameter for YIN algorithm
  ///
  /// \param o YIN pitch detection object
  /// \param tol tolerance parameter for minima selection [default 0.15]
  int aubio_pitchyinfast_set_tolerance(
    ffi.Pointer<aubio_pitchyinfast_t> o,
    double tol,
  ) {
    return _aubio_pitchyinfast_set_tolerance(
      o,
      tol,
    );
  }

  late final _aubio_pitchyinfast_set_tolerancePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pitchyinfast_t>,
              smpl_t)>>('aubio_pitchyinfast_set_tolerance');
  late final _aubio_pitchyinfast_set_tolerance =
      _aubio_pitchyinfast_set_tolerancePtr.asFunction<
          int Function(ffi.Pointer<aubio_pitchyinfast_t>, double)>();

  /// get tolerance parameter for YIN algorithm
  ///
  /// \param o YIN pitch detection object
  /// \return tolerance parameter for minima selection [default 0.15]
  double aubio_pitchyinfast_get_tolerance(
    ffi.Pointer<aubio_pitchyinfast_t> o,
  ) {
    return _aubio_pitchyinfast_get_tolerance(
      o,
    );
  }

  late final _aubio_pitchyinfast_get_tolerancePtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchyinfast_t>)>>(
      'aubio_pitchyinfast_get_tolerance');
  late final _aubio_pitchyinfast_get_tolerance =
      _aubio_pitchyinfast_get_tolerancePtr
          .asFunction<double Function(ffi.Pointer<aubio_pitchyinfast_t>)>();

  /// get current confidence of YIN algorithm
  ///
  /// \param o YIN pitch detection object
  /// \return confidence parameter
  double aubio_pitchyinfast_get_confidence(
    ffi.Pointer<aubio_pitchyinfast_t> o,
  ) {
    return _aubio_pitchyinfast_get_confidence(
      o,
    );
  }

  late final _aubio_pitchyinfast_get_confidencePtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchyinfast_t>)>>(
      'aubio_pitchyinfast_get_confidence');
  late final _aubio_pitchyinfast_get_confidence =
      _aubio_pitchyinfast_get_confidencePtr
          .asFunction<double Function(ffi.Pointer<aubio_pitchyinfast_t>)>();

  /// execute pitch detection on an input spectral frame
  ///
  /// \param p pitch detection object as returned by new_aubio_pitchmcomb
  /// \param in_fftgrain input signal spectrum as computed by aubio_pvoc_do
  /// \param out_cands pitch candidate frequenciess, in bins
  void aubio_pitchmcomb_do(
    ffi.Pointer<aubio_pitchmcomb_t> p,
    ffi.Pointer<cvec_t> in_fftgrain,
    ffi.Pointer<fvec_t> out_cands,
  ) {
    return _aubio_pitchmcomb_do(
      p,
      in_fftgrain,
      out_cands,
    );
  }

  late final _aubio_pitchmcomb_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchmcomb_t>,
              ffi.Pointer<cvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pitchmcomb_do');
  late final _aubio_pitchmcomb_do = _aubio_pitchmcomb_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pitchmcomb_t>, ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// creation of the pitch detection object
  ///
  /// \param buf_size size of the input buffer to analyse
  /// \param hop_size step size between two consecutive analysis instant
  ffi.Pointer<aubio_pitchmcomb_t> new_aubio_pitchmcomb(
    int buf_size,
    int hop_size,
  ) {
    return _new_aubio_pitchmcomb(
      buf_size,
      hop_size,
    );
  }

  late final _new_aubio_pitchmcombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_pitchmcomb_t> Function(
              uint_t, uint_t)>>('new_aubio_pitchmcomb');
  late final _new_aubio_pitchmcomb = _new_aubio_pitchmcombPtr
      .asFunction<ffi.Pointer<aubio_pitchmcomb_t> Function(int, int)>();

  /// deletion of the pitch detection object
  ///
  /// \param p pitch detection object as returned by new_aubio_pitchfcomb
  void del_aubio_pitchmcomb(
    ffi.Pointer<aubio_pitchmcomb_t> p,
  ) {
    return _del_aubio_pitchmcomb(
      p,
    );
  }

  late final _del_aubio_pitchmcombPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_pitchmcomb_t>)>>(
      'del_aubio_pitchmcomb');
  late final _del_aubio_pitchmcomb = _del_aubio_pitchmcombPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitchmcomb_t>)>();

  ffi.Pointer<aubio_audio_unit_t> new_aubio_audio_unit(
    int samplerate,
    int inchannels,
    int outchannels,
    int blocksize,
  ) {
    return _new_aubio_audio_unit(
      samplerate,
      inchannels,
      outchannels,
      blocksize,
    );
  }

  late final _new_aubio_audio_unitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_audio_unit_t> Function(
              uint_t, uint_t, uint_t, uint_t)>>('new_aubio_audio_unit');
  late final _new_aubio_audio_unit = _new_aubio_audio_unitPtr.asFunction<
      ffi.Pointer<aubio_audio_unit_t> Function(int, int, int, int)>();

  int aubio_audio_unit_set_callback(
    ffi.Pointer<aubio_audio_unit_t> o,
    aubio_device_callback_t callback,
    ffi.Pointer<ffi.Void> closure,
  ) {
    return _aubio_audio_unit_set_callback(
      o,
      callback,
      closure,
    );
  }

  late final _aubio_audio_unit_set_callbackPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(
              ffi.Pointer<aubio_audio_unit_t>,
              aubio_device_callback_t,
              ffi.Pointer<ffi.Void>)>>('aubio_audio_unit_set_callback');
  late final _aubio_audio_unit_set_callback =
      _aubio_audio_unit_set_callbackPtr.asFunction<
          int Function(ffi.Pointer<aubio_audio_unit_t>, aubio_device_callback_t,
              ffi.Pointer<ffi.Void>)>();

  int aubio_audio_unit_set_verbose(
    ffi.Pointer<aubio_audio_unit_t> o,
    int verbose,
  ) {
    return _aubio_audio_unit_set_verbose(
      o,
      verbose,
    );
  }

  late final _aubio_audio_unit_set_verbosePtr = _lookup<
      ffi.NativeFunction<
          sint_t Function(ffi.Pointer<aubio_audio_unit_t>,
              uint_t)>>('aubio_audio_unit_set_verbose');
  late final _aubio_audio_unit_set_verbose = _aubio_audio_unit_set_verbosePtr
      .asFunction<int Function(ffi.Pointer<aubio_audio_unit_t>, int)>();

  int aubio_audio_unit_set_preferred_latency(
    ffi.Pointer<aubio_audio_unit_t> o,
    double latency,
  ) {
    return _aubio_audio_unit_set_preferred_latency(
      o,
      latency,
    );
  }

  late final _aubio_audio_unit_set_preferred_latencyPtr = _lookup<
      ffi.NativeFunction<
          sint_t Function(ffi.Pointer<aubio_audio_unit_t>,
              smpl_t)>>('aubio_audio_unit_set_preferred_latency');
  late final _aubio_audio_unit_set_preferred_latency =
      _aubio_audio_unit_set_preferred_latencyPtr
          .asFunction<int Function(ffi.Pointer<aubio_audio_unit_t>, double)>();

  int aubio_audio_unit_set_prevent_feedback(
    ffi.Pointer<aubio_audio_unit_t> o,
    int prevent_feedback,
  ) {
    return _aubio_audio_unit_set_prevent_feedback(
      o,
      prevent_feedback,
    );
  }

  late final _aubio_audio_unit_set_prevent_feedbackPtr = _lookup<
      ffi.NativeFunction<
          sint_t Function(ffi.Pointer<aubio_audio_unit_t>,
              uint_t)>>('aubio_audio_unit_set_prevent_feedback');
  late final _aubio_audio_unit_set_prevent_feedback =
      _aubio_audio_unit_set_prevent_feedbackPtr
          .asFunction<int Function(ffi.Pointer<aubio_audio_unit_t>, int)>();

  int aubio_audio_unit_get_info(
    ffi.Pointer<aubio_audio_unit_t> o,
  ) {
    return _aubio_audio_unit_get_info(
      o,
    );
  }

  late final _aubio_audio_unit_get_infoPtr = _lookup<
          ffi.NativeFunction<sint_t Function(ffi.Pointer<aubio_audio_unit_t>)>>(
      'aubio_audio_unit_get_info');
  late final _aubio_audio_unit_get_info = _aubio_audio_unit_get_infoPtr
      .asFunction<int Function(ffi.Pointer<aubio_audio_unit_t>)>();

  int aubio_audio_unit_init(
    ffi.Pointer<aubio_audio_unit_t> o,
  ) {
    return _aubio_audio_unit_init(
      o,
    );
  }

  late final _aubio_audio_unit_initPtr = _lookup<
          ffi.NativeFunction<sint_t Function(ffi.Pointer<aubio_audio_unit_t>)>>(
      'aubio_audio_unit_init');
  late final _aubio_audio_unit_init = _aubio_audio_unit_initPtr
      .asFunction<int Function(ffi.Pointer<aubio_audio_unit_t>)>();

  int aubio_audio_unit_start(
    ffi.Pointer<aubio_audio_unit_t> o,
  ) {
    return _aubio_audio_unit_start(
      o,
    );
  }

  late final _aubio_audio_unit_startPtr = _lookup<
          ffi.NativeFunction<sint_t Function(ffi.Pointer<aubio_audio_unit_t>)>>(
      'aubio_audio_unit_start');
  late final _aubio_audio_unit_start = _aubio_audio_unit_startPtr
      .asFunction<int Function(ffi.Pointer<aubio_audio_unit_t>)>();

  int aubio_audio_unit_stop(
    ffi.Pointer<aubio_audio_unit_t> o,
  ) {
    return _aubio_audio_unit_stop(
      o,
    );
  }

  late final _aubio_audio_unit_stopPtr = _lookup<
          ffi.NativeFunction<sint_t Function(ffi.Pointer<aubio_audio_unit_t>)>>(
      'aubio_audio_unit_stop');
  late final _aubio_audio_unit_stop = _aubio_audio_unit_stopPtr
      .asFunction<int Function(ffi.Pointer<aubio_audio_unit_t>)>();

  int del_aubio_audio_unit(
    ffi.Pointer<aubio_audio_unit_t> o,
  ) {
    return _del_aubio_audio_unit(
      o,
    );
  }

  late final _del_aubio_audio_unitPtr = _lookup<
          ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_audio_unit_t>)>>(
      'del_aubio_audio_unit');
  late final _del_aubio_audio_unit = _del_aubio_audio_unitPtr
      .asFunction<int Function(ffi.Pointer<aubio_audio_unit_t>)>();

  /// validate samplerate
  ///
  /// \param kind       the object kind to report on
  /// \param path       the object properties to report on
  /// \param samplerate the object properties to report on
  /// \return  0 if ok, non-zero if validation failed
  int aubio_io_validate_samplerate(
    ffi.Pointer<char_t> kind,
    ffi.Pointer<char_t> path,
    int samplerate,
  ) {
    return _aubio_io_validate_samplerate(
      kind,
      path,
      samplerate,
    );
  }

  late final _aubio_io_validate_sampleratePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>,
              uint_t)>>('aubio_io_validate_samplerate');
  late final _aubio_io_validate_samplerate =
      _aubio_io_validate_sampleratePtr.asFunction<
          int Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>, int)>();

  /// validate number of channels
  ///
  /// \param kind       the object kind to report on
  /// \param path       the object properties to report on
  /// \param channels   the object properties to report on
  /// \return  0 if ok, non-zero if validation failed
  int aubio_io_validate_channels(
    ffi.Pointer<char_t> kind,
    ffi.Pointer<char_t> path,
    int channels,
  ) {
    return _aubio_io_validate_channels(
      kind,
      path,
      channels,
    );
  }

  late final _aubio_io_validate_channelsPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>,
              uint_t)>>('aubio_io_validate_channels');
  late final _aubio_io_validate_channels =
      _aubio_io_validate_channelsPtr.asFunction<
          int Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>, int)>();

  /// validate length of source output
  ///
  /// \param kind       the object kind to report on
  /// \param path       the path to report on
  /// \param hop_size   number of frames to be read
  /// \param read_data_length actual length of input
  ///
  /// \return hop_size or the maximum number of frames that can be written
  int aubio_source_validate_input_length(
    ffi.Pointer<char_t> kind,
    ffi.Pointer<char_t> path,
    int hop_size,
    int read_data_length,
  ) {
    return _aubio_source_validate_input_length(
      kind,
      path,
      hop_size,
      read_data_length,
    );
  }

  late final _aubio_source_validate_input_lengthPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>, uint_t,
              uint_t)>>('aubio_source_validate_input_length');
  late final _aubio_source_validate_input_length =
      _aubio_source_validate_input_lengthPtr.asFunction<
          int Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>, int, int)>();

  /// validate height of source output
  ///
  /// \param kind       the object kind to report on
  /// \param path       the path to report on
  /// \param source_channels maximum number of channels that can be written
  /// \param read_data_height actual height of input
  ///
  /// \return write_data_height or the maximum number of channels
  int aubio_source_validate_input_channels(
    ffi.Pointer<char_t> kind,
    ffi.Pointer<char_t> path,
    int source_channels,
    int read_data_height,
  ) {
    return _aubio_source_validate_input_channels(
      kind,
      path,
      source_channels,
      read_data_height,
    );
  }

  late final _aubio_source_validate_input_channelsPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>, uint_t,
              uint_t)>>('aubio_source_validate_input_channels');
  late final _aubio_source_validate_input_channels =
      _aubio_source_validate_input_channelsPtr.asFunction<
          int Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>, int, int)>();

  /// pad end of source output vector with zeroes
  ///
  /// \param read_data   output vector to pad
  /// \param source_read number of frames read
  void aubio_source_pad_output(
    ffi.Pointer<fvec_t> read_data,
    int source_read,
  ) {
    return _aubio_source_pad_output(
      read_data,
      source_read,
    );
  }

  late final _aubio_source_pad_outputPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, uint_t)>>(
      'aubio_source_pad_output');
  late final _aubio_source_pad_output = _aubio_source_pad_outputPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, int)>();

  /// pad end of source output matrix with zeroes
  ///
  /// \param read_data   output matrix to pad
  /// \param source_channels number of channels in the source
  /// \param source_read number of frames read
  void aubio_source_pad_multi_output(
    ffi.Pointer<fmat_t> read_data,
    int source_channels,
    int source_read,
  ) {
    return _aubio_source_pad_multi_output(
      read_data,
      source_channels,
      source_read,
    );
  }

  late final _aubio_source_pad_multi_outputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fmat_t>, uint_t,
              uint_t)>>('aubio_source_pad_multi_output');
  late final _aubio_source_pad_multi_output = _aubio_source_pad_multi_outputPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>, int, int)>();

  /// validate length of sink input
  ///
  /// \param kind       the object kind to report on
  /// \param path       the path to report on
  /// \param max_size   maximum number of frames that can be written
  /// \param write_data_length actual length of input
  /// \param write number of samples asked
  ///
  /// \return write or the maximum number of frames that can be written
  int aubio_sink_validate_input_length(
    ffi.Pointer<char_t> kind,
    ffi.Pointer<char_t> path,
    int max_size,
    int write_data_length,
    int write,
  ) {
    return _aubio_sink_validate_input_length(
      kind,
      path,
      max_size,
      write_data_length,
      write,
    );
  }

  late final _aubio_sink_validate_input_lengthPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>, uint_t,
              uint_t, uint_t)>>('aubio_sink_validate_input_length');
  late final _aubio_sink_validate_input_length =
      _aubio_sink_validate_input_lengthPtr.asFunction<
          int Function(
              ffi.Pointer<char_t>, ffi.Pointer<char_t>, int, int, int)>();

  /// validate height of sink input
  ///
  /// \param kind       the object kind to report on
  /// \param path       the path to report on
  /// \param sink_channels maximum number of channels that can be written
  /// \param write_data_height actual height of input matrix
  ///
  /// \return write_data_height or the maximum number of channels
  int aubio_sink_validate_input_channels(
    ffi.Pointer<char_t> kind,
    ffi.Pointer<char_t> path,
    int sink_channels,
    int write_data_height,
  ) {
    return _aubio_sink_validate_input_channels(
      kind,
      path,
      sink_channels,
      write_data_height,
    );
  }

  late final _aubio_sink_validate_input_channelsPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>, uint_t,
              uint_t)>>('aubio_sink_validate_input_channels');
  late final _aubio_sink_validate_input_channels =
      _aubio_sink_validate_input_channelsPtr.asFunction<
          int Function(ffi.Pointer<char_t>, ffi.Pointer<char_t>, int, int)>();

  /// create a scale object
  ///
  /// \param flow lower value of output function
  /// \param fhig higher value of output function
  /// \param ilow lower value of input function
  /// \param ihig higher value of output function
  ffi.Pointer<aubio_scale_t> new_aubio_scale(
    double flow,
    double fhig,
    double ilow,
    double ihig,
  ) {
    return _new_aubio_scale(
      flow,
      fhig,
      ilow,
      ihig,
    );
  }

  late final _new_aubio_scalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_scale_t> Function(
              smpl_t, smpl_t, smpl_t, smpl_t)>>('new_aubio_scale');
  late final _new_aubio_scale = _new_aubio_scalePtr.asFunction<
      ffi.Pointer<aubio_scale_t> Function(double, double, double, double)>();

  /// delete a scale object
  ///
  /// \param s scale object as returned by new_aubio_scale
  void del_aubio_scale(
    ffi.Pointer<aubio_scale_t> s,
  ) {
    return _del_aubio_scale(
      s,
    );
  }

  late final _del_aubio_scalePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_scale_t>)>>(
      'del_aubio_scale');
  late final _del_aubio_scale = _del_aubio_scalePtr
      .asFunction<void Function(ffi.Pointer<aubio_scale_t>)>();

  /// scale input vector
  ///
  /// \param s scale object as returned by new_aubio_scale
  /// \param input vector to scale
  void aubio_scale_do(
    ffi.Pointer<aubio_scale_t> s,
    ffi.Pointer<fvec_t> input,
  ) {
    return _aubio_scale_do(
      s,
      input,
    );
  }

  late final _aubio_scale_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_scale_t>,
              ffi.Pointer<fvec_t>)>>('aubio_scale_do');
  late final _aubio_scale_do = _aubio_scale_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_scale_t>, ffi.Pointer<fvec_t>)>();

  /// modify scale parameters after object creation
  ///
  /// \param s scale object as returned by new_aubio_scale
  /// \param olow lower value of output function
  /// \param ohig higher value of output function
  /// \param ilow lower value of input function
  /// \param ihig higher value of output function
  int aubio_scale_set_limits(
    ffi.Pointer<aubio_scale_t> s,
    double ilow,
    double ihig,
    double olow,
    double ohig,
  ) {
    return _aubio_scale_set_limits(
      s,
      ilow,
      ihig,
      olow,
      ohig,
    );
  }

  late final _aubio_scale_set_limitsPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_scale_t>, smpl_t, smpl_t, smpl_t,
              smpl_t)>>('aubio_scale_set_limits');
  late final _aubio_scale_set_limits = _aubio_scale_set_limitsPtr.asFunction<
      int Function(
          ffi.Pointer<aubio_scale_t>, double, double, double, double)>();

  /// histogram creation
  ///
  /// \param flow minimum input
  /// \param fhig maximum input
  /// \param nelems number of histogram columns
  ffi.Pointer<aubio_hist_t> new_aubio_hist(
    double flow,
    double fhig,
    int nelems,
  ) {
    return _new_aubio_hist(
      flow,
      fhig,
      nelems,
    );
  }

  late final _new_aubio_histPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_hist_t> Function(
              smpl_t, smpl_t, uint_t)>>('new_aubio_hist');
  late final _new_aubio_hist = _new_aubio_histPtr
      .asFunction<ffi.Pointer<aubio_hist_t> Function(double, double, int)>();

  /// histogram deletion
  void del_aubio_hist(
    ffi.Pointer<aubio_hist_t> s,
  ) {
    return _del_aubio_hist(
      s,
    );
  }

  late final _del_aubio_histPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_hist_t>)>>(
          'del_aubio_hist');
  late final _del_aubio_hist =
      _del_aubio_histPtr.asFunction<void Function(ffi.Pointer<aubio_hist_t>)>();

  /// compute the histogram
  void aubio_hist_do(
    ffi.Pointer<aubio_hist_t> s,
    ffi.Pointer<fvec_t> input,
  ) {
    return _aubio_hist_do(
      s,
      input,
    );
  }

  late final _aubio_hist_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_hist_t>,
              ffi.Pointer<fvec_t>)>>('aubio_hist_do');
  late final _aubio_hist_do = _aubio_hist_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_hist_t>, ffi.Pointer<fvec_t>)>();

  /// compute the histogram ignoring null elements
  void aubio_hist_do_notnull(
    ffi.Pointer<aubio_hist_t> s,
    ffi.Pointer<fvec_t> input,
  ) {
    return _aubio_hist_do_notnull(
      s,
      input,
    );
  }

  late final _aubio_hist_do_notnullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_hist_t>,
              ffi.Pointer<fvec_t>)>>('aubio_hist_do_notnull');
  late final _aubio_hist_do_notnull = _aubio_hist_do_notnullPtr.asFunction<
      void Function(ffi.Pointer<aubio_hist_t>, ffi.Pointer<fvec_t>)>();

  /// compute the mean of the histogram
  double aubio_hist_mean(
    ffi.Pointer<aubio_hist_t> s,
  ) {
    return _aubio_hist_mean(
      s,
    );
  }

  late final _aubio_hist_meanPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_hist_t>)>>(
          'aubio_hist_mean');
  late final _aubio_hist_mean = _aubio_hist_meanPtr
      .asFunction<double Function(ffi.Pointer<aubio_hist_t>)>();

  /// weight the histogram
  void aubio_hist_weight(
    ffi.Pointer<aubio_hist_t> s,
  ) {
    return _aubio_hist_weight(
      s,
    );
  }

  late final _aubio_hist_weightPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_hist_t>)>>(
          'aubio_hist_weight');
  late final _aubio_hist_weight = _aubio_hist_weightPtr
      .asFunction<void Function(ffi.Pointer<aubio_hist_t>)>();

  /// compute dynamic histogram for non-null elements
  void aubio_hist_dyn_notnull(
    ffi.Pointer<aubio_hist_t> s,
    ffi.Pointer<fvec_t> input,
  ) {
    return _aubio_hist_dyn_notnull(
      s,
      input,
    );
  }

  late final _aubio_hist_dyn_notnullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_hist_t>,
              ffi.Pointer<fvec_t>)>>('aubio_hist_dyn_notnull');
  late final _aubio_hist_dyn_notnull = _aubio_hist_dyn_notnullPtr.asFunction<
      void Function(ffi.Pointer<aubio_hist_t>, ffi.Pointer<fvec_t>)>();

  /// create beat tracking object
  ///
  /// \param winlen length of the onset detection window
  /// \param hop_size number of onset detection samples [512]
  /// \param samplerate samplerate of the input signal
  ffi.Pointer<aubio_beattracking_t> new_aubio_beattracking(
    int winlen,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_beattracking(
      winlen,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_beattrackingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_beattracking_t> Function(
              uint_t, uint_t, uint_t)>>('new_aubio_beattracking');
  late final _new_aubio_beattracking = _new_aubio_beattrackingPtr
      .asFunction<ffi.Pointer<aubio_beattracking_t> Function(int, int, int)>();

  /// track the beat
  ///
  /// \param bt beat tracking object
  /// \param dfframes current input detection function frame, smoothed by
  /// adaptive median threshold.
  /// \param out stored detected beat locations
  void aubio_beattracking_do(
    ffi.Pointer<aubio_beattracking_t> bt,
    ffi.Pointer<fvec_t> dfframes,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_beattracking_do(
      bt,
      dfframes,
      out,
    );
  }

  late final _aubio_beattracking_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_beattracking_t>,
              ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_beattracking_do');
  late final _aubio_beattracking_do = _aubio_beattracking_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_beattracking_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// get current beat period in samples
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the currently observed period, in samples, or 0 if no consistent
  /// value is found.
  double aubio_beattracking_get_period(
    ffi.Pointer<aubio_beattracking_t> bt,
  ) {
    return _aubio_beattracking_get_period(
      bt,
    );
  }

  late final _aubio_beattracking_get_periodPtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_beattracking_t>)>>(
      'aubio_beattracking_get_period');
  late final _aubio_beattracking_get_period = _aubio_beattracking_get_periodPtr
      .asFunction<double Function(ffi.Pointer<aubio_beattracking_t>)>();

  /// get current beat period in seconds
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the currently observed period, in seconds, or 0 if no consistent
  /// value is found.
  double aubio_beattracking_get_period_s(
    ffi.Pointer<aubio_beattracking_t> bt,
  ) {
    return _aubio_beattracking_get_period_s(
      bt,
    );
  }

  late final _aubio_beattracking_get_period_sPtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_beattracking_t>)>>(
      'aubio_beattracking_get_period_s');
  late final _aubio_beattracking_get_period_s =
      _aubio_beattracking_get_period_sPtr
          .asFunction<double Function(ffi.Pointer<aubio_beattracking_t>)>();

  /// get current tempo in bpm
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the currently observed tempo, in beats per minutes, or 0 if no
  /// consistent value is found.
  double aubio_beattracking_get_bpm(
    ffi.Pointer<aubio_beattracking_t> bt,
  ) {
    return _aubio_beattracking_get_bpm(
      bt,
    );
  }

  late final _aubio_beattracking_get_bpmPtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_beattracking_t>)>>(
      'aubio_beattracking_get_bpm');
  late final _aubio_beattracking_get_bpm = _aubio_beattracking_get_bpmPtr
      .asFunction<double Function(ffi.Pointer<aubio_beattracking_t>)>();

  /// get current tempo confidence
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the confidence with which the tempo has been observed, 0 if no
  /// consistent value is found.
  double aubio_beattracking_get_confidence(
    ffi.Pointer<aubio_beattracking_t> bt,
  ) {
    return _aubio_beattracking_get_confidence(
      bt,
    );
  }

  late final _aubio_beattracking_get_confidencePtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_beattracking_t>)>>(
      'aubio_beattracking_get_confidence');
  late final _aubio_beattracking_get_confidence =
      _aubio_beattracking_get_confidencePtr
          .asFunction<double Function(ffi.Pointer<aubio_beattracking_t>)>();

  /// delete beat tracking object
  ///
  /// \param p beat tracking object
  void del_aubio_beattracking(
    ffi.Pointer<aubio_beattracking_t> p,
  ) {
    return _del_aubio_beattracking(
      p,
    );
  }

  late final _del_aubio_beattrackingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_beattracking_t>)>>('del_aubio_beattracking');
  late final _del_aubio_beattracking = _del_aubio_beattrackingPtr
      .asFunction<void Function(ffi.Pointer<aubio_beattracking_t>)>();

  /// execute time stretching on an input signal frame
  ///
  /// \param o time stretching object as returned by new_aubio_timestretch()
  /// \param out timestretched output of size [hop_size]
  /// \param read number of frames actually wrote out
  void aubio_timestretch_do(
    ffi.Pointer<aubio_timestretch_t> o,
    ffi.Pointer<fvec_t> out,
    ffi.Pointer<uint_t> read,
  ) {
    return _aubio_timestretch_do(
      o,
      out,
      read,
    );
  }

  late final _aubio_timestretch_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_timestretch_t>,
              ffi.Pointer<fvec_t>,
              ffi.Pointer<uint_t>)>>('aubio_timestretch_do');
  late final _aubio_timestretch_do = _aubio_timestretch_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_timestretch_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<uint_t>)>();

  /// deletion of the time stretching object
  ///
  /// \param o time stretching object as returned by new_aubio_timestretch()
  void del_aubio_timestretch(
    ffi.Pointer<aubio_timestretch_t> o,
  ) {
    return _del_aubio_timestretch(
      o,
    );
  }

  late final _del_aubio_timestretchPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_timestretch_t>)>>(
      'del_aubio_timestretch');
  late final _del_aubio_timestretch = _del_aubio_timestretchPtr
      .asFunction<void Function(ffi.Pointer<aubio_timestretch_t>)>();

  /// creation of the time stretching object
  ///
  /// \param method time stretching algorithm ("default")
  /// \param stretch initial time stretching factor
  /// \param hop_size block size at which the frames should be produced
  /// \param samplerate sampling rate of the signal
  ///
  /// \return newly created ::aubio_timestretch_t
  ffi.Pointer<aubio_timestretch_t> new_aubio_timestretch(
    ffi.Pointer<char_t> method,
    double stretch,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_timestretch(
      method,
      stretch,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_timestretchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_timestretch_t> Function(ffi.Pointer<char_t>, smpl_t,
              uint_t, uint_t)>>('new_aubio_timestretch');
  late final _new_aubio_timestretch = _new_aubio_timestretchPtr.asFunction<
      ffi.Pointer<aubio_timestretch_t> Function(
          ffi.Pointer<char_t>, double, int, int)>();

  /// push length samples from in to time stretching object
  ///
  /// \param o time stretching object as returned by ::new_aubio_timestretch()
  /// \param in input vector of new samples to push to time stretching object
  /// \param length number of new samples to push from input vector
  ///
  /// \return number of currently available samples
  int aubio_timestretch_push(
    ffi.Pointer<aubio_timestretch_t> o,
    ffi.Pointer<fvec_t> in1,
    int length,
  ) {
    return _aubio_timestretch_push(
      o,
      in1,
      length,
    );
  }

  late final _aubio_timestretch_pushPtr = _lookup<
      ffi.NativeFunction<
          sint_t Function(ffi.Pointer<aubio_timestretch_t>, ffi.Pointer<fvec_t>,
              uint_t)>>('aubio_timestretch_push');
  late final _aubio_timestretch_push = _aubio_timestretch_pushPtr.asFunction<
      int Function(
          ffi.Pointer<aubio_timestretch_t>, ffi.Pointer<fvec_t>, int)>();

  /// get number of currently available samples from time stretching object
  ///
  /// \param o time stretching object as returned by ::new_aubio_timestretch()
  ///
  /// \return number of currently available samples
  int aubio_timestretch_get_available(
    ffi.Pointer<aubio_timestretch_t> o,
  ) {
    return _aubio_timestretch_get_available(
      o,
    );
  }

  late final _aubio_timestretch_get_availablePtr = _lookup<
          ffi
          .NativeFunction<sint_t Function(ffi.Pointer<aubio_timestretch_t>)>>(
      'aubio_timestretch_get_available');
  late final _aubio_timestretch_get_available =
      _aubio_timestretch_get_availablePtr
          .asFunction<int Function(ffi.Pointer<aubio_timestretch_t>)>();

  /// get the latency of the time stretching object, in samples
  ///
  /// \param o time stretching object as returned by ::new_aubio_timestretch()
  ///
  /// \return latency of the time stretching object in samples
  int aubio_timestretch_get_latency(
    ffi.Pointer<aubio_timestretch_t> o,
  ) {
    return _aubio_timestretch_get_latency(
      o,
    );
  }

  late final _aubio_timestretch_get_latencyPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_timestretch_t>)>>(
      'aubio_timestretch_get_latency');
  late final _aubio_timestretch_get_latency = _aubio_timestretch_get_latencyPtr
      .asFunction<int Function(ffi.Pointer<aubio_timestretch_t>)>();

  /// get the samplerate of the time stretching object
  ///
  /// Call after new_aubio_timestretch() was called with 0 to match the original
  /// samplerate of the input file.
  ///
  /// \param o time stretching object as returned by new_aubio_timestretch()
  ///
  /// \return samplerate of the time stretching object
  int aubio_timestretch_get_samplerate(
    ffi.Pointer<aubio_timestretch_t> o,
  ) {
    return _aubio_timestretch_get_samplerate(
      o,
    );
  }

  late final _aubio_timestretch_get_sampleratePtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_timestretch_t>)>>(
      'aubio_timestretch_get_samplerate');
  late final _aubio_timestretch_get_samplerate =
      _aubio_timestretch_get_sampleratePtr
          .asFunction<int Function(ffi.Pointer<aubio_timestretch_t>)>();

  /// set the stretching ratio of the time stretching object
  ///
  /// \param o time stretching object as returned by new_aubio_timestretch()
  /// \param stretch new time stretching ratio of the time stretching object
  /// (should be in the range [0.025; 10.])
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_timestretch_set_stretch(
    ffi.Pointer<aubio_timestretch_t> o,
    double stretch,
  ) {
    return _aubio_timestretch_set_stretch(
      o,
      stretch,
    );
  }

  late final _aubio_timestretch_set_stretchPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_timestretch_t>,
              smpl_t)>>('aubio_timestretch_set_stretch');
  late final _aubio_timestretch_set_stretch = _aubio_timestretch_set_stretchPtr
      .asFunction<int Function(ffi.Pointer<aubio_timestretch_t>, double)>();

  /// get the transposition of the time stretching object, in semitones
  ///
  /// \param o time stretching object as returned by ::new_aubio_timestretch()
  ///
  /// \return time stretching ratio of the time stretching object, in the range
  /// [0.025; 10.]
  double aubio_timestretch_get_stretch(
    ffi.Pointer<aubio_timestretch_t> o,
  ) {
    return _aubio_timestretch_get_stretch(
      o,
    );
  }

  late final _aubio_timestretch_get_stretchPtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_timestretch_t>)>>(
      'aubio_timestretch_get_stretch');
  late final _aubio_timestretch_get_stretch = _aubio_timestretch_get_stretchPtr
      .asFunction<double Function(ffi.Pointer<aubio_timestretch_t>)>();

  /// set the pitch scale of the time stretching object
  ///
  /// \param o time stretching object as returned by new_aubio_timestretch()
  /// \param pitchscale new pitch scale of the time stretching object
  ///
  /// pitchscale is a frequency ratio. It should be in the range [0.25, 4].
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_timestretch_set_pitchscale(
    ffi.Pointer<aubio_timestretch_t> o,
    double pitchscale,
  ) {
    return _aubio_timestretch_set_pitchscale(
      o,
      pitchscale,
    );
  }

  late final _aubio_timestretch_set_pitchscalePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_timestretch_t>,
              smpl_t)>>('aubio_timestretch_set_pitchscale');
  late final _aubio_timestretch_set_pitchscale =
      _aubio_timestretch_set_pitchscalePtr
          .asFunction<int Function(ffi.Pointer<aubio_timestretch_t>, double)>();

  /// get the pitchscale of the time stretching object
  ///
  /// \param o time stretching object as returned by ::new_aubio_timestretch()
  ///
  /// \return pitchscale of the time stretching object
  double aubio_timestretch_get_pitchscale(
    ffi.Pointer<aubio_timestretch_t> o,
  ) {
    return _aubio_timestretch_get_pitchscale(
      o,
    );
  }

  late final _aubio_timestretch_get_pitchscalePtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_timestretch_t>)>>(
      'aubio_timestretch_get_pitchscale');
  late final _aubio_timestretch_get_pitchscale =
      _aubio_timestretch_get_pitchscalePtr
          .asFunction<double Function(ffi.Pointer<aubio_timestretch_t>)>();

  /// set the transposition of the time stretching object, in semitones
  ///
  /// \param o time stretching object as returned by new_aubio_timestretch()
  ///
  /// \param transpose new pitch transposition of the time stretching object,
  /// expressed in semitones (should be in the range [-24;+24])
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_timestretch_set_transpose(
    ffi.Pointer<aubio_timestretch_t> o,
    double transpose,
  ) {
    return _aubio_timestretch_set_transpose(
      o,
      transpose,
    );
  }

  late final _aubio_timestretch_set_transposePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_timestretch_t>,
              smpl_t)>>('aubio_timestretch_set_transpose');
  late final _aubio_timestretch_set_transpose =
      _aubio_timestretch_set_transposePtr
          .asFunction<int Function(ffi.Pointer<aubio_timestretch_t>, double)>();

  /// get the transposition of the time stretching object, in semitones
  ///
  /// \param o time stretching object as returned by ::new_aubio_timestretch()
  ///
  /// \return transposition of the time stretching object, in semitones
  double aubio_timestretch_get_transpose(
    ffi.Pointer<aubio_timestretch_t> o,
  ) {
    return _aubio_timestretch_get_transpose(
      o,
    );
  }

  late final _aubio_timestretch_get_transposePtr = _lookup<
          ffi
          .NativeFunction<smpl_t Function(ffi.Pointer<aubio_timestretch_t>)>>(
      'aubio_timestretch_get_transpose');
  late final _aubio_timestretch_get_transpose =
      _aubio_timestretch_get_transposePtr
          .asFunction<double Function(ffi.Pointer<aubio_timestretch_t>)>();

  /// reset the time stretching object
  ///
  /// \param o time stretching object as returned by ::new_aubio_timestretch()
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_timestretch_reset(
    ffi.Pointer<aubio_timestretch_t> o,
  ) {
    return _aubio_timestretch_reset(
      o,
    );
  }

  late final _aubio_timestretch_resetPtr = _lookup<
          ffi
          .NativeFunction<uint_t Function(ffi.Pointer<aubio_timestretch_t>)>>(
      'aubio_timestretch_reset');
  late final _aubio_timestretch_reset = _aubio_timestretch_resetPtr
      .asFunction<int Function(ffi.Pointer<aubio_timestretch_t>)>();

  /// execute pitch shifting on an input signal frame
  ///
  /// \param o pitch shifting object as returned by new_aubio_pitchshift()
  /// \param in input signal of size [hop_size]
  /// \param out output pitch candidates of size [1]
  void aubio_pitchshift_do(
    ffi.Pointer<aubio_pitchshift_t> o,
    ffi.Pointer<fvec_t> in1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_pitchshift_do(
      o,
      in1,
      out,
    );
  }

  late final _aubio_pitchshift_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_pitchshift_t>,
              ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_pitchshift_do');
  late final _aubio_pitchshift_do = _aubio_pitchshift_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_pitchshift_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// deletion of the pitch shifting object
  ///
  /// \param o pitch shifting object as returned by new_aubio_pitchshift()
  void del_aubio_pitchshift(
    ffi.Pointer<aubio_pitchshift_t> o,
  ) {
    return _del_aubio_pitchshift(
      o,
    );
  }

  late final _del_aubio_pitchshiftPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_pitchshift_t>)>>(
      'del_aubio_pitchshift');
  late final _del_aubio_pitchshift = _del_aubio_pitchshiftPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitchshift_t>)>();

  /// creation of the pitch shifting object
  ///
  /// \param method set pitch shifting algorithm ("default")
  /// \param transpose initial pitch transposition
  /// \param hop_size step size between two consecutive analysis instant
  /// \param samplerate sampling rate of the signal
  ///
  /// \return newly created ::aubio_pitchshift_t
  ffi.Pointer<aubio_pitchshift_t> new_aubio_pitchshift(
    ffi.Pointer<char_t> method,
    double transpose,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_pitchshift(
      method,
      transpose,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_pitchshiftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aubio_pitchshift_t> Function(ffi.Pointer<char_t>, smpl_t,
              uint_t, uint_t)>>('new_aubio_pitchshift');
  late final _new_aubio_pitchshift = _new_aubio_pitchshiftPtr.asFunction<
      ffi.Pointer<aubio_pitchshift_t> Function(
          ffi.Pointer<char_t>, double, int, int)>();

  /// get the latency of the pitch shifting object, in samples
  ///
  /// \param o pitch shifting object as returned by ::new_aubio_pitchshift()
  ///
  /// \return latency of the pitch shifting object in samples
  int aubio_pitchshift_get_latency(
    ffi.Pointer<aubio_pitchshift_t> o,
  ) {
    return _aubio_pitchshift_get_latency(
      o,
    );
  }

  late final _aubio_pitchshift_get_latencyPtr = _lookup<
          ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_pitchshift_t>)>>(
      'aubio_pitchshift_get_latency');
  late final _aubio_pitchshift_get_latency = _aubio_pitchshift_get_latencyPtr
      .asFunction<int Function(ffi.Pointer<aubio_pitchshift_t>)>();

  /// set the pitch scale of the pitch shifting object
  ///
  /// \param o pitch shifting object as returned by new_aubio_pitchshift()
  /// \param pitchscale new pitch scale of the pitch shifting object
  ///
  /// pitchscale is a frequency ratio. It should be in the range [0.25, 4].
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_pitchshift_set_pitchscale(
    ffi.Pointer<aubio_pitchshift_t> o,
    double pitchscale,
  ) {
    return _aubio_pitchshift_set_pitchscale(
      o,
      pitchscale,
    );
  }

  late final _aubio_pitchshift_set_pitchscalePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pitchshift_t>,
              smpl_t)>>('aubio_pitchshift_set_pitchscale');
  late final _aubio_pitchshift_set_pitchscale =
      _aubio_pitchshift_set_pitchscalePtr
          .asFunction<int Function(ffi.Pointer<aubio_pitchshift_t>, double)>();

  /// get the pitchscale of the pitch shifting object
  ///
  /// \param o pitch shifting object as returned by ::new_aubio_pitchshift()
  ///
  /// \return pitchscale of the pitch shifting object
  double aubio_pitchshift_get_pitchscale(
    ffi.Pointer<aubio_pitchshift_t> o,
  ) {
    return _aubio_pitchshift_get_pitchscale(
      o,
    );
  }

  late final _aubio_pitchshift_get_pitchscalePtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchshift_t>)>>(
      'aubio_pitchshift_get_pitchscale');
  late final _aubio_pitchshift_get_pitchscale =
      _aubio_pitchshift_get_pitchscalePtr
          .asFunction<double Function(ffi.Pointer<aubio_pitchshift_t>)>();

  /// set the transposition of the pitch shifting object, in semitones
  ///
  /// \param o pitch shifting object as returned by new_aubio_pitchshift()
  /// \param transpose new pitch transposition of the pitch shifting object,
  /// expressed in semitones (should be in the range [-24;+24])
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_pitchshift_set_transpose(
    ffi.Pointer<aubio_pitchshift_t> o,
    double transpose,
  ) {
    return _aubio_pitchshift_set_transpose(
      o,
      transpose,
    );
  }

  late final _aubio_pitchshift_set_transposePtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pitchshift_t>,
              smpl_t)>>('aubio_pitchshift_set_transpose');
  late final _aubio_pitchshift_set_transpose =
      _aubio_pitchshift_set_transposePtr
          .asFunction<int Function(ffi.Pointer<aubio_pitchshift_t>, double)>();

  /// get the transposition of the pitch shifting object, in semitones
  ///
  /// \param o pitch shifting object as returned by ::new_aubio_pitchshift()
  ///
  /// \return transposition of the pitch shifting object, in semitones
  double aubio_pitchshift_get_transpose(
    ffi.Pointer<aubio_pitchshift_t> o,
  ) {
    return _aubio_pitchshift_get_transpose(
      o,
    );
  }

  late final _aubio_pitchshift_get_transposePtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitchshift_t>)>>(
      'aubio_pitchshift_get_transpose');
  late final _aubio_pitchshift_get_transpose =
      _aubio_pitchshift_get_transposePtr
          .asFunction<double Function(ffi.Pointer<aubio_pitchshift_t>)>();

  /// peak-picker creation function
  ffi.Pointer<aubio_peakpicker_t> new_aubio_peakpicker() {
    return _new_aubio_peakpicker();
  }

  late final _new_aubio_peakpickerPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_peakpicker_t> Function()>>(
          'new_aubio_peakpicker');
  late final _new_aubio_peakpicker = _new_aubio_peakpickerPtr
      .asFunction<ffi.Pointer<aubio_peakpicker_t> Function()>();

  /// real time peak picking function
  void aubio_peakpicker_do(
    ffi.Pointer<aubio_peakpicker_t> p,
    ffi.Pointer<fvec_t> in1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_peakpicker_do(
      p,
      in1,
      out,
    );
  }

  late final _aubio_peakpicker_doPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_peakpicker_t>,
              ffi.Pointer<fvec_t>,
              ffi.Pointer<fvec_t>)>>('aubio_peakpicker_do');
  late final _aubio_peakpicker_do = _aubio_peakpicker_doPtr.asFunction<
      void Function(ffi.Pointer<aubio_peakpicker_t>, ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>)>();

  /// destroy peak picker structure
  void del_aubio_peakpicker(
    ffi.Pointer<aubio_peakpicker_t> p,
  ) {
    return _del_aubio_peakpicker(
      p,
    );
  }

  late final _del_aubio_peakpickerPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aubio_peakpicker_t>)>>(
      'del_aubio_peakpicker');
  late final _del_aubio_peakpicker = _del_aubio_peakpickerPtr
      .asFunction<void Function(ffi.Pointer<aubio_peakpicker_t>)>();

  /// get current peak value
  ffi.Pointer<fvec_t> aubio_peakpicker_get_thresholded_input(
    ffi.Pointer<aubio_peakpicker_t> p,
  ) {
    return _aubio_peakpicker_get_thresholded_input(
      p,
    );
  }

  late final _aubio_peakpicker_get_thresholded_inputPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<fvec_t> Function(ffi.Pointer<aubio_peakpicker_t>)>>(
      'aubio_peakpicker_get_thresholded_input');
  late final _aubio_peakpicker_get_thresholded_input =
      _aubio_peakpicker_get_thresholded_inputPtr.asFunction<
          ffi.Pointer<fvec_t> Function(ffi.Pointer<aubio_peakpicker_t>)>();

  /// set peak picking threshold
  int aubio_peakpicker_set_threshold(
    ffi.Pointer<aubio_peakpicker_t> p,
    double threshold,
  ) {
    return _aubio_peakpicker_set_threshold(
      p,
      threshold,
    );
  }

  late final _aubio_peakpicker_set_thresholdPtr = _lookup<
      ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_peakpicker_t>,
              smpl_t)>>('aubio_peakpicker_set_threshold');
  late final _aubio_peakpicker_set_threshold =
      _aubio_peakpicker_set_thresholdPtr
          .asFunction<int Function(ffi.Pointer<aubio_peakpicker_t>, double)>();

  /// get peak picking threshold
  double aubio_peakpicker_get_threshold(
    ffi.Pointer<aubio_peakpicker_t> p,
  ) {
    return _aubio_peakpicker_get_threshold(
      p,
    );
  }

  late final _aubio_peakpicker_get_thresholdPtr = _lookup<
          ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_peakpicker_t>)>>(
      'aubio_peakpicker_get_threshold');
  late final _aubio_peakpicker_get_threshold =
      _aubio_peakpicker_get_thresholdPtr
          .asFunction<double Function(ffi.Pointer<aubio_peakpicker_t>)>();
}

/// Buffer for real data
///
/// Vector of real-valued data
///
/// ::fvec_t is is the structure used to store vector of real-valued data, ::smpl_t .
///
/// \code
///
/// uint_t buffer_size = 1024;
///
/// // create a vector of 512 values
/// fvec_t * input = new_fvec (buffer_size);
///
/// // set some values of the vector
/// input->data[23] = 2.;
/// // ..
///
/// // compute the mean of the vector
/// mean = fvec_mean(a_vector);
///
/// // destroy the vector
/// del_fvec(a_vector);
///
/// \endcode
///
/// See `examples/` and `tests/src` directories for more examples.
final class fvec_t extends ffi.Struct {
  /// < length of buffer
  @uint_t()
  external int length;

  /// < data vector of length ::fvec_t.length
  external ffi.Pointer<smpl_t> data;
}

/// unsigned integer
typedef uint_t = ffi.UnsignedInt;
typedef Dartuint_t = int;
typedef smpl_t = ffi.Float;
typedef Dartsmpl_t = double;

/// Vector of real-valued phase and spectrum data
///
/// \code
///
/// uint_t buffer_size = 1024;
///
/// // create a complex vector of 512 values
/// cvec_t * input = new_cvec (buffer_size);
///
/// // set some values of the vector
/// input->norm[23] = 2.;
/// input->phas[23] = M_PI;
/// // ..
///
/// // compute the mean of the vector
/// mean = cvec_mean(input);
///
/// // destroy the vector
/// del_cvec (input);
///
/// \endcode
final class cvec_t extends ffi.Struct {
  /// < length of buffer = (requested length)/2 + 1
  @uint_t()
  external int length;

  /// < norm array of size ::cvec_t.length
  external ffi.Pointer<smpl_t> norm;

  /// < phase array of size ::cvec_t.length
  external ffi.Pointer<smpl_t> phas;
}

/// Buffer for real data in double precision
final class lvec_t extends ffi.Struct {
  /// < length of buffer
  @uint_t()
  external int length;

  /// < data array of size [length]
  external ffi.Pointer<lsmp_t> data;
}

typedef lsmp_t = ffi.Double;
typedef Dartlsmp_t = double;

/// Buffer for real data
final class fmat_t extends ffi.Struct {
  /// < length of matrix
  @uint_t()
  external int length;

  /// < height of matrix
  @uint_t()
  external int height;

  /// < data array of size [length] * [height]
  external ffi.Pointer<ffi.Pointer<smpl_t>> data;
}

/// character
typedef char_t = ffi.Char;
typedef Dartchar_t = int;

final class _aubio_resampler_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> dummy;
}

/// resampler object
typedef aubio_resampler_t = _aubio_resampler_t;

final class _aubio_filter_t extends ffi.Struct {
  @uint_t()
  external int order;

  @uint_t()
  external int samplerate;

  external ffi.Pointer<lvec_t> a;

  external ffi.Pointer<lvec_t> b;

  external ffi.Pointer<lvec_t> y;

  external ffi.Pointer<lvec_t> x;
}

/// Digital filter
typedef aubio_filter_t = _aubio_filter_t;

final class _aubio_fft_t extends ffi.Struct {
  @uint_t()
  external int winsize;

  @uint_t()
  external int fft_size;

  external ffi.Pointer<smpl_t> in1;

  external ffi.Pointer<smpl_t> out;

  external ffi.Pointer<smpl_t> w;

  external ffi.Pointer<ffi.Int> ip;

  external ffi.Pointer<fvec_t> compspec;
}

/// FFT object
///
/// This object computes forward and backward FFTs.
typedef aubio_fft_t = _aubio_fft_t;

final class _aubio_dct_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> dct;

  external aubio_dct_do_t dct_do;

  external aubio_dct_rdo_t dct_rdo;

  external del_aubio_dct_t del_dct;
}

/// function pointers prototypes
typedef aubio_dct_do_t
    = ffi.Pointer<ffi.NativeFunction<aubio_dct_do_tFunction>>;
typedef aubio_dct_do_tFunction = ffi.Void Function(ffi.Pointer<aubio_dct_t> s,
    ffi.Pointer<fvec_t> input, ffi.Pointer<fvec_t> output);
typedef Dartaubio_dct_do_tFunction = void Function(ffi.Pointer<aubio_dct_t> s,
    ffi.Pointer<fvec_t> input, ffi.Pointer<fvec_t> output);

/// DCT object
///
/// This object computes forward and backward DCT type 2 with orthonormal
/// scaling.
typedef aubio_dct_t = _aubio_dct_t;
typedef aubio_dct_rdo_t
    = ffi.Pointer<ffi.NativeFunction<aubio_dct_rdo_tFunction>>;
typedef aubio_dct_rdo_tFunction = ffi.Void Function(ffi.Pointer<aubio_dct_t> s,
    ffi.Pointer<fvec_t> input, ffi.Pointer<fvec_t> output);
typedef Dartaubio_dct_rdo_tFunction = void Function(ffi.Pointer<aubio_dct_t> s,
    ffi.Pointer<fvec_t> input, ffi.Pointer<fvec_t> output);
typedef del_aubio_dct_t
    = ffi.Pointer<ffi.NativeFunction<del_aubio_dct_tFunction>>;
typedef del_aubio_dct_tFunction = ffi.Void Function(ffi.Pointer<aubio_dct_t> s);
typedef Dartdel_aubio_dct_tFunction = void Function(ffi.Pointer<aubio_dct_t> s);

/// phasevocoder internal object
final class _aubio_pvoc_t extends ffi.Struct {
  @uint_t()
  external int win_s;

  /// grain length
  @uint_t()
  external int hop_s;

  /// overlap step
  external ffi.Pointer<aubio_fft_t> fft;

  /// fft object
  external ffi.Pointer<fvec_t> data;

  /// current input grain, [win_s] frames
  external ffi.Pointer<fvec_t> dataold;

  /// memory of past grain, [win_s-hop_s] frames
  external ffi.Pointer<fvec_t> synth;

  /// current output grain, [win_s] frames
  external ffi.Pointer<fvec_t> synthold;

  /// memory of past grain, [win_s-hop_s] frames
  external ffi.Pointer<fvec_t> w;

  /// grain window [win_s]
  @uint_t()
  external int start;

  /// where to start additive synthesis
  @uint_t()
  external int end;

  /// where to end it
  @smpl_t()
  external double scale;

  /// scaling factor for synthesis
  @uint_t()
  external int end_datasize;

  /// size of memory to end
  @uint_t()
  external int hop_datasize;
}

/// phasevocoder object
typedef aubio_pvoc_t = _aubio_pvoc_t;

/// \brief A structure to store a set of n_filters filters of lenghts win_s
final class _aubio_filterbank_t extends ffi.Struct {
  @uint_t()
  external int win_s;

  @uint_t()
  external int n_filters;

  external ffi.Pointer<fmat_t> filters;

  @smpl_t()
  external double norm;

  @smpl_t()
  external double power;
}

/// filterbank object
///
/// This object stores a matrix of spectral filter coefficients.
typedef aubio_filterbank_t = _aubio_filterbank_t;

/// Internal structure for mfcc object
final class _aubio_mfcc_t extends ffi.Struct {
  @uint_t()
  external int win_s;

  /// grain length
  @uint_t()
  external int samplerate;

  /// sample rate (needed?)
  @uint_t()
  external int n_filters;

  /// number of filters
  @uint_t()
  external int n_coefs;

  /// number of coefficients (<= n_filters/2 +1)
  external ffi.Pointer<aubio_filterbank_t> fb;

  /// filter bank
  external ffi.Pointer<fvec_t> in_dct;

  /// input buffer for dct * [fb->n_filters]
  external ffi.Pointer<aubio_dct_t> dct;

  /// dct object
  external ffi.Pointer<fvec_t> output;

  /// dct output
  @smpl_t()
  external double scale;
}

/// mfcc object
typedef aubio_mfcc_t = _aubio_mfcc_t;

/// structure to store object state
final class _aubio_specdesc_t extends ffi.Struct {
  /// < onset detection type
  @ffi.Int32()
  external int onset_type;

  /// Pointer to aubio_specdesc_<type> function
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aubio_specdesc_t> o,
              ffi.Pointer<cvec_t> fftgrain,
              ffi.Pointer<fvec_t> onset)>> funcpointer;

  /// < minimum norm threshold for phase and specdiff
  @smpl_t()
  external double threshold;

  /// < previous norm vector
  external ffi.Pointer<fvec_t> oldmag;

  /// < current onset detection measure vector
  external ffi.Pointer<fvec_t> dev1;

  /// < previous phase vector, one frame behind
  external ffi.Pointer<fvec_t> theta1;

  /// < previous phase vector, two frames behind
  external ffi.Pointer<fvec_t> theta2;

  /// < histogram
  external ffi.Pointer<aubio_hist_t> histog;
}

/// onsetdetection types
abstract class aubio_specdesc_type {
  /// < energy based
  static const int aubio_onset_energy = 0;

  /// < spectral diff
  static const int aubio_onset_specdiff = 1;

  /// < high frequency content
  static const int aubio_onset_hfc = 2;

  /// < complex domain
  static const int aubio_onset_complex = 3;

  /// < phase fast
  static const int aubio_onset_phase = 4;

  /// < weighted phase
  static const int aubio_onset_wphase = 5;

  /// < Kullback Liebler
  static const int aubio_onset_kl = 6;

  /// < modified Kullback Liebler
  static const int aubio_onset_mkl = 7;

  /// < spectral flux
  static const int aubio_onset_specflux = 8;

  /// < spectral centroid
  static const int aubio_specmethod_centroid = 9;

  /// < spectral spread
  static const int aubio_specmethod_spread = 10;

  /// < spectral skewness
  static const int aubio_specmethod_skewness = 11;

  /// < spectral kurtosis
  static const int aubio_specmethod_kurtosis = 12;

  /// < spectral kurtosis
  static const int aubio_specmethod_slope = 13;

  /// < spectral decrease
  static const int aubio_specmethod_decrease = 14;

  /// < spectral rolloff
  static const int aubio_specmethod_rolloff = 15;

  /// < default mode, set to hfc
  static const int aubio_onset_default = 2;
}

/// spectral description structure
typedef aubio_specdesc_t = _aubio_specdesc_t;

/// histogram object
typedef aubio_hist_t = _aubio_hist_t;

/// Object Structure
final class _aubio_hist_t extends ffi.Struct {
  external ffi.Pointer<fvec_t> hist;

  @uint_t()
  external int nelems;

  external ffi.Pointer<fvec_t> cent;

  external ffi.Pointer<aubio_scale_t> scaler;
}

/// scale object
typedef aubio_scale_t = _aubio_scale_t;

final class _aubio_scale_t extends ffi.Struct {
  @smpl_t()
  external double ilow;

  @smpl_t()
  external double ihig;

  @smpl_t()
  external double olow;

  @smpl_t()
  external double ohig;

  @smpl_t()
  external double scaler;

  @smpl_t()
  external double irange;
}

/// structure to store object state
final class _aubio_spectral_whitening_t extends ffi.Struct {
  @uint_t()
  external int buf_size;

  @uint_t()
  external int hop_size;

  @uint_t()
  external int samplerate;

  @smpl_t()
  external double relax_time;

  @smpl_t()
  external double r_decay;

  @smpl_t()
  external double floor;

  external ffi.Pointer<fvec_t> peak_values;
}

/// spectral whitening structure
typedef aubio_spectral_whitening_t = _aubio_spectral_whitening_t;

final class _aubio_tss_t extends ffi.Struct {
  @smpl_t()
  external double threshold;

  @smpl_t()
  external double alpha;

  @smpl_t()
  external double beta;

  @smpl_t()
  external double parm;

  @smpl_t()
  external double thrsfact;

  external ffi.Pointer<fvec_t> theta1;

  external ffi.Pointer<fvec_t> theta2;

  external ffi.Pointer<fvec_t> oft1;

  external ffi.Pointer<fvec_t> oft2;

  external ffi.Pointer<fvec_t> dev;
}

/// Transient / Steady-state Separation object
typedef aubio_tss_t = _aubio_tss_t;

/// generic pitch detection structure
final class _aubio_pitch_t extends ffi.Struct {
  /// < pitch detection mode
  @ffi.Int32()
  external int type;

  /// < pitch detection output mode
  @ffi.Int32()
  external int mode;

  /// < samplerate
  @uint_t()
  external int samplerate;

  /// < buffer size
  @uint_t()
  external int bufsize;

  /// < pointer to pitch object
  external ffi.Pointer<ffi.Void> p_object;

  /// < filter
  external ffi.Pointer<aubio_filter_t> filter;

  /// < filtered input
  external ffi.Pointer<fvec_t> filtered;

  /// < phase vocoder for mcomb
  external ffi.Pointer<aubio_pvoc_t> pv;

  /// < spectral frame for mcomb
  external ffi.Pointer<cvec_t> fftgrain;

  /// < temporary buffer for yin
  external ffi.Pointer<fvec_t> buf;

  /// < callback to get the pitch candidates
  external aubio_pitch_detect_t detect_cb;

  /// < callback to convert it to the desired unit
  external aubio_pitch_convert_t conv_cb;

  /// < pointer to the current confidence callback
  external aubio_pitch_get_conf_t conf_cb;

  /// < silence threshold
  @smpl_t()
  external double silence;
}

/// pitch detection algorithms
abstract class aubio_pitch_type {
  /// < `yin`, YIN algorithm
  static const int aubio_pitcht_yin = 0;

  /// < `mcomb`, Multi-comb filter
  static const int aubio_pitcht_mcomb = 1;

  /// < `schmitt`, Schmitt trigger
  static const int aubio_pitcht_schmitt = 2;

  /// < `fcomb`, Fast comb filter
  static const int aubio_pitcht_fcomb = 3;

  /// < `yinfft`, Spectral YIN
  static const int aubio_pitcht_yinfft = 4;

  /// < `yinfast`, YIN fast
  static const int aubio_pitcht_yinfast = 5;

  /// < `specacf`, Spectral autocorrelation
  static const int aubio_pitcht_specacf = 6;
  static const int aubio_pitcht_default = 4;
}

/// pitch detection output modes
abstract class aubio_pitch_mode {
  /// < Frequency (Hz)
  static const int aubio_pitchm_freq = 0;

  /// < MIDI note (0.,127)
  static const int aubio_pitchm_midi = 1;

  /// < Cent
  static const int aubio_pitchm_cent = 2;

  /// < Frequency bin (0,bufsize)
  static const int aubio_pitchm_bin = 3;

  /// < the one used when "default" is asked
  static const int aubio_pitchm_default = 0;
}

/// callback to get pitch candidate, defined below
typedef aubio_pitch_detect_t
    = ffi.Pointer<ffi.NativeFunction<aubio_pitch_detect_tFunction>>;
typedef aubio_pitch_detect_tFunction = ffi.Void Function(
    ffi.Pointer<aubio_pitch_t> p,
    ffi.Pointer<fvec_t> ibuf,
    ffi.Pointer<fvec_t> obuf);
typedef Dartaubio_pitch_detect_tFunction = void Function(
    ffi.Pointer<aubio_pitch_t> p,
    ffi.Pointer<fvec_t> ibuf,
    ffi.Pointer<fvec_t> obuf);

/// pitch detection object
typedef aubio_pitch_t = _aubio_pitch_t;

/// callback to convert pitch from one unit to another, defined below
typedef aubio_pitch_convert_t
    = ffi.Pointer<ffi.NativeFunction<aubio_pitch_convert_tFunction>>;
typedef aubio_pitch_convert_tFunction = smpl_t Function(
    smpl_t value, uint_t samplerate, uint_t bufsize);
typedef Dartaubio_pitch_convert_tFunction = Dartsmpl_t Function(
    Dartsmpl_t value, Dartuint_t samplerate, Dartuint_t bufsize);

/// callback to fetch the confidence of the algorithm
typedef aubio_pitch_get_conf_t
    = ffi.Pointer<ffi.NativeFunction<aubio_pitch_get_conf_tFunction>>;
typedef aubio_pitch_get_conf_tFunction = smpl_t Function(
    ffi.Pointer<ffi.Void> p);
typedef Dartaubio_pitch_get_conf_tFunction = Dartsmpl_t Function(
    ffi.Pointer<ffi.Void> p);

/// structure to store object state
final class _aubio_onset_t extends ffi.Struct {
  /// < phase vocoder
  external ffi.Pointer<aubio_pvoc_t> pv;

  /// < spectral descriptor
  external ffi.Pointer<aubio_specdesc_t> od;

  /// < peak picker
  external ffi.Pointer<aubio_peakpicker_t> pp;

  /// < phase vocoder output
  external ffi.Pointer<cvec_t> fftgrain;

  /// < spectral description
  external ffi.Pointer<fvec_t> desc;

  /// < silence threhsold
  @smpl_t()
  external double silence;

  /// < minimum inter onset interval
  @uint_t()
  external int minioi;

  /// < constant delay, in samples, removed from detected onset times
  @uint_t()
  external int delay;

  /// < sampling rate of the input signal
  @uint_t()
  external int samplerate;

  /// < number of samples between two runs
  @uint_t()
  external int hop_size;

  /// < total number of frames processed since the beginning
  @uint_t()
  external int total_frames;

  /// < last detected onset location, in frames
  @uint_t()
  external int last_onset;

  @uint_t()
  external int apply_compression;

  @smpl_t()
  external double lambda_compression;

  /// < apply adaptive spectral whitening
  @uint_t()
  external int apply_awhitening;

  external ffi.Pointer<aubio_spectral_whitening_t> spectral_whitening;
}

/// peak-picker structure
typedef aubio_peakpicker_t = _aubio_peakpicker_t;

/// peak picking parameters, default values in brackets
///
/// [<----post----|--pre-->]
/// .................|.............
/// time->           ^now
final class _aubio_peakpicker_t extends ffi.Struct {
  /// thresh: offset threshold [0.033 or 0.01]
  @smpl_t()
  external double threshold;

  /// win_post: median filter window length (causal part) [8]
  @uint_t()
  external int win_post;

  /// pre: median filter window (anti-causal part) [post-1]
  @uint_t()
  external int win_pre;

  /// threshfn: name or handle of fn for computing adaptive threshold [median]
  external aubio_thresholdfn_t thresholdfn;

  /// picker: name or handle of fn for picking event times [peakpick]
  external aubio_pickerfn_t pickerfn;

  /// biquad lowpass filter
  external ffi.Pointer<aubio_filter_t> biquad;

  /// original onsets
  external ffi.Pointer<fvec_t> onset_keep;

  /// modified onsets
  external ffi.Pointer<fvec_t> onset_proc;

  /// peak picked window [3]
  external ffi.Pointer<fvec_t> onset_peek;

  /// thresholded function
  external ffi.Pointer<fvec_t> thresholded;

  /// scratch pad for biquad and median
  external ffi.Pointer<fvec_t> scratch;
}

/// function pointer to thresholding function
typedef aubio_thresholdfn_t
    = ffi.Pointer<ffi.NativeFunction<aubio_thresholdfn_tFunction>>;
typedef aubio_thresholdfn_tFunction = smpl_t Function(
    ffi.Pointer<fvec_t> input);
typedef Dartaubio_thresholdfn_tFunction = Dartsmpl_t Function(
    ffi.Pointer<fvec_t> input);

/// function pointer to peak-picking function
typedef aubio_pickerfn_t
    = ffi.Pointer<ffi.NativeFunction<aubio_pickerfn_tFunction>>;
typedef aubio_pickerfn_tFunction = uint_t Function(
    ffi.Pointer<fvec_t> input, uint_t pos);
typedef Dartaubio_pickerfn_tFunction = Dartuint_t Function(
    ffi.Pointer<fvec_t> input, Dartuint_t pos);

/// onset detection object
typedef aubio_onset_t = _aubio_onset_t;

/// structure to store object state
final class _aubio_tempo_t extends ffi.Struct {
  external ffi.Pointer<aubio_specdesc_t> od;

  /// onset detection
  external ffi.Pointer<aubio_pvoc_t> pv;

  /// phase vocoder
  external ffi.Pointer<aubio_peakpicker_t> pp;

  /// peak picker
  external ffi.Pointer<aubio_beattracking_t> bt;

  /// beat tracking
  external ffi.Pointer<cvec_t> fftgrain;

  /// spectral frame
  external ffi.Pointer<fvec_t> of;

  /// onset detection function value
  external ffi.Pointer<fvec_t> dfframe;

  /// peak picked detection function buffer
  external ffi.Pointer<fvec_t> out;

  /// beat tactus candidates
  external ffi.Pointer<fvec_t> onset;

  /// onset results
  @smpl_t()
  external double silence;

  /// silence parameter
  @smpl_t()
  external double threshold;

  /// peak picking threshold
  @sint_t()
  external int blockpos;

  /// current position in dfframe
  @uint_t()
  external int winlen;

  /// dfframe bufsize
  @uint_t()
  external int step;

  /// dfframe hopsize
  @uint_t()
  external int samplerate;

  /// sampling rate of the signal
  @uint_t()
  external int hop_size;

  /// get hop_size
  @uint_t()
  external int total_frames;

  /// total frames since beginning
  @uint_t()
  external int last_beat;

  /// time of latest detected beat, in samples
  @sint_t()
  external int delay;

  /// delay to remove to last beat, in samples
  @uint_t()
  external int last_tatum;

  /// time of latest detected tatum, in samples
  @uint_t()
  external int tatum_signature;
}

/// beat tracking object
typedef aubio_beattracking_t = _aubio_beattracking_t;

final class _aubio_beattracking_t extends ffi.Struct {
  @uint_t()
  external int hop_size;

  /// length of one tempo detection function sample, in audio samples
  @uint_t()
  external int samplerate;

  /// samplerate of the original signal
  external ffi.Pointer<fvec_t> rwv;

  /// rayleigh weighting for beat period in general model
  external ffi.Pointer<fvec_t> dfwv;

  /// exponential weighting for beat alignment in general model
  external ffi.Pointer<fvec_t> gwv;

  /// gaussian weighting for beat period in context dependant model
  external ffi.Pointer<fvec_t> phwv;

  /// gaussian weighting for beat alignment in context dependant model
  external ffi.Pointer<fvec_t> dfrev;

  /// reversed onset detection function
  external ffi.Pointer<fvec_t> acf;

  /// vector for autocorrelation function (of current detection function frame)
  external ffi.Pointer<fvec_t> acfout;

  /// store result of passing acf through s.i.c.f.b.
  external ffi.Pointer<fvec_t> phout;

  @uint_t()
  external int timesig;

  /// time signature of input, set to zero until context dependent model activated
  @uint_t()
  external int step;

  @uint_t()
  external int rayparam;

  /// Rayleigh parameter
  @smpl_t()
  external double lastbeat;

  @sint_t()
  external int counter;

  @uint_t()
  external int flagstep;

  @smpl_t()
  external double g_var;

  @smpl_t()
  external double gp;

  @smpl_t()
  external double bp;

  @smpl_t()
  external double rp;

  @smpl_t()
  external double rp1;

  @smpl_t()
  external double rp2;
}

/// signed integer
typedef sint_t = ffi.Int;
typedef Dartsint_t = int;

/// tempo detection structure
typedef aubio_tempo_t = _aubio_tempo_t;

final class _aubio_notes_t extends ffi.Struct {
  @uint_t()
  external int onset_buf_size;

  @uint_t()
  external int pitch_buf_size;

  @uint_t()
  external int hop_size;

  @uint_t()
  external int samplerate;

  @uint_t()
  external int median;

  external ffi.Pointer<fvec_t> note_buffer;

  external ffi.Pointer<fvec_t> note_buffer2;

  external ffi.Pointer<aubio_pitch_t> pitch;

  external ffi.Pointer<fvec_t> pitch_output;

  @smpl_t()
  external double pitch_tolerance;

  external ffi.Pointer<aubio_onset_t> onset;

  external ffi.Pointer<fvec_t> onset_output;

  @smpl_t()
  external double onset_threshold;

  @smpl_t()
  external double curnote;

  @smpl_t()
  external double newnote;

  @smpl_t()
  external double silence_threshold;

  @uint_t()
  external int isready;

  @smpl_t()
  external double last_onset_level;

  @smpl_t()
  external double release_drop_level;
}

/// notes detection object
typedef aubio_notes_t = _aubio_notes_t;

final class _aubio_source_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> source;

  external aubio_source_do_t s_do;

  external aubio_source_do_multi_t s_do_multi;

  external aubio_source_get_samplerate_t s_get_samplerate;

  external aubio_source_get_channels_t s_get_channels;

  external aubio_source_get_duration_t s_get_duration;

  external aubio_source_seek_t s_seek;

  external aubio_source_close_t s_close;

  external del_aubio_source_t s_del;
}

typedef aubio_source_do_t
    = ffi.Pointer<ffi.NativeFunction<aubio_source_do_tFunction>>;
typedef aubio_source_do_tFunction = ffi.Void Function(
    ffi.Pointer<aubio_source_t> s,
    ffi.Pointer<fvec_t> data,
    ffi.Pointer<uint_t> read);
typedef Dartaubio_source_do_tFunction = void Function(
    ffi.Pointer<aubio_source_t> s,
    ffi.Pointer<fvec_t> data,
    ffi.Pointer<uint_t> read);

/// media source object
typedef aubio_source_t = _aubio_source_t;
typedef aubio_source_do_multi_t
    = ffi.Pointer<ffi.NativeFunction<aubio_source_do_multi_tFunction>>;
typedef aubio_source_do_multi_tFunction = ffi.Void Function(
    ffi.Pointer<aubio_source_t> s,
    ffi.Pointer<fmat_t> data,
    ffi.Pointer<uint_t> read);
typedef Dartaubio_source_do_multi_tFunction = void Function(
    ffi.Pointer<aubio_source_t> s,
    ffi.Pointer<fmat_t> data,
    ffi.Pointer<uint_t> read);
typedef aubio_source_get_samplerate_t
    = ffi.Pointer<ffi.NativeFunction<aubio_source_get_samplerate_tFunction>>;
typedef aubio_source_get_samplerate_tFunction = uint_t Function(
    ffi.Pointer<aubio_source_t> s);
typedef Dartaubio_source_get_samplerate_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_source_t> s);
typedef aubio_source_get_channels_t
    = ffi.Pointer<ffi.NativeFunction<aubio_source_get_channels_tFunction>>;
typedef aubio_source_get_channels_tFunction = uint_t Function(
    ffi.Pointer<aubio_source_t> s);
typedef Dartaubio_source_get_channels_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_source_t> s);
typedef aubio_source_get_duration_t
    = ffi.Pointer<ffi.NativeFunction<aubio_source_get_duration_tFunction>>;
typedef aubio_source_get_duration_tFunction = uint_t Function(
    ffi.Pointer<aubio_source_t> s);
typedef Dartaubio_source_get_duration_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_source_t> s);
typedef aubio_source_seek_t
    = ffi.Pointer<ffi.NativeFunction<aubio_source_seek_tFunction>>;
typedef aubio_source_seek_tFunction = uint_t Function(
    ffi.Pointer<aubio_source_t> s, uint_t seek);
typedef Dartaubio_source_seek_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_source_t> s, Dartuint_t seek);
typedef aubio_source_close_t
    = ffi.Pointer<ffi.NativeFunction<aubio_source_close_tFunction>>;
typedef aubio_source_close_tFunction = uint_t Function(
    ffi.Pointer<aubio_source_t> s);
typedef Dartaubio_source_close_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_source_t> s);
typedef del_aubio_source_t
    = ffi.Pointer<ffi.NativeFunction<del_aubio_source_tFunction>>;
typedef del_aubio_source_tFunction = ffi.Void Function(
    ffi.Pointer<aubio_source_t> s);
typedef Dartdel_aubio_source_tFunction = void Function(
    ffi.Pointer<aubio_source_t> s);

final class _aubio_sink_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> sink;

  external aubio_sink_do_t s_do;

  external aubio_sink_do_multi_t s_do_multi;

  external aubio_sink_preset_samplerate_t s_preset_samplerate;

  external aubio_sink_preset_channels_t s_preset_channels;

  external aubio_sink_get_samplerate_t s_get_samplerate;

  external aubio_sink_get_channels_t s_get_channels;

  external aubio_sink_close_t s_close;

  external del_aubio_sink_t s_del;
}

typedef aubio_sink_do_t
    = ffi.Pointer<ffi.NativeFunction<aubio_sink_do_tFunction>>;
typedef aubio_sink_do_tFunction = ffi.Void Function(
    ffi.Pointer<aubio_sink_t> s, ffi.Pointer<fvec_t> data, uint_t write);
typedef Dartaubio_sink_do_tFunction = void Function(
    ffi.Pointer<aubio_sink_t> s, ffi.Pointer<fvec_t> data, Dartuint_t write);

/// media sink object
typedef aubio_sink_t = _aubio_sink_t;
typedef aubio_sink_do_multi_t
    = ffi.Pointer<ffi.NativeFunction<aubio_sink_do_multi_tFunction>>;
typedef aubio_sink_do_multi_tFunction = ffi.Void Function(
    ffi.Pointer<aubio_sink_t> s, ffi.Pointer<fmat_t> data, uint_t write);
typedef Dartaubio_sink_do_multi_tFunction = void Function(
    ffi.Pointer<aubio_sink_t> s, ffi.Pointer<fmat_t> data, Dartuint_t write);
typedef aubio_sink_preset_samplerate_t
    = ffi.Pointer<ffi.NativeFunction<aubio_sink_preset_samplerate_tFunction>>;
typedef aubio_sink_preset_samplerate_tFunction = uint_t Function(
    ffi.Pointer<aubio_sink_t> s, uint_t samplerate);
typedef Dartaubio_sink_preset_samplerate_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_sink_t> s, Dartuint_t samplerate);
typedef aubio_sink_preset_channels_t
    = ffi.Pointer<ffi.NativeFunction<aubio_sink_preset_channels_tFunction>>;
typedef aubio_sink_preset_channels_tFunction = uint_t Function(
    ffi.Pointer<aubio_sink_t> s, uint_t channels);
typedef Dartaubio_sink_preset_channels_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_sink_t> s, Dartuint_t channels);
typedef aubio_sink_get_samplerate_t
    = ffi.Pointer<ffi.NativeFunction<aubio_sink_get_samplerate_tFunction>>;
typedef aubio_sink_get_samplerate_tFunction = uint_t Function(
    ffi.Pointer<aubio_sink_t> s);
typedef Dartaubio_sink_get_samplerate_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_sink_t> s);
typedef aubio_sink_get_channels_t
    = ffi.Pointer<ffi.NativeFunction<aubio_sink_get_channels_tFunction>>;
typedef aubio_sink_get_channels_tFunction = uint_t Function(
    ffi.Pointer<aubio_sink_t> s);
typedef Dartaubio_sink_get_channels_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_sink_t> s);
typedef aubio_sink_close_t
    = ffi.Pointer<ffi.NativeFunction<aubio_sink_close_tFunction>>;
typedef aubio_sink_close_tFunction = uint_t Function(
    ffi.Pointer<aubio_sink_t> s);
typedef Dartaubio_sink_close_tFunction = Dartuint_t Function(
    ffi.Pointer<aubio_sink_t> s);
typedef del_aubio_sink_t
    = ffi.Pointer<ffi.NativeFunction<del_aubio_sink_tFunction>>;
typedef del_aubio_sink_tFunction = ffi.Void Function(
    ffi.Pointer<aubio_sink_t> s);
typedef Dartdel_aubio_sink_tFunction = void Function(
    ffi.Pointer<aubio_sink_t> s);

final class _aubio_sampler_t extends ffi.Struct {
  @uint_t()
  external int samplerate;

  @uint_t()
  external int blocksize;

  external ffi.Pointer<aubio_source_t> source;

  external ffi.Pointer<fvec_t> source_output;

  external ffi.Pointer<fmat_t> source_output_multi;

  external ffi.Pointer<char_t> uri;

  @uint_t()
  external int playing;
}

/// sampler object
typedef aubio_sampler_t = _aubio_sampler_t;

final class _aubio_wavetable_t extends ffi.Struct {
  @uint_t()
  external int samplerate;

  @uint_t()
  external int blocksize;

  @uint_t()
  external int wavetable_length;

  external ffi.Pointer<fvec_t> wavetable;

  @uint_t()
  external int playing;

  @smpl_t()
  external double last_pos;

  external ffi.Pointer<aubio_parameter_t> freq;

  external ffi.Pointer<aubio_parameter_t> amp;
}

/// parameter object
typedef aubio_parameter_t = _aubio_parameter_t;

final class _aubio_parameter_t extends ffi.Struct {
  @smpl_t()
  external double current_value;

  @smpl_t()
  external double target_value;

  @smpl_t()
  external double increment;

  @smpl_t()
  external double max_value;

  @smpl_t()
  external double min_value;

  @uint_t()
  external int steps;
}

/// wavetable object
typedef aubio_wavetable_t = _aubio_wavetable_t;

/// list of logging levels
abstract class aubio_log_level {
  /// < critical errors
  static const int AUBIO_LOG_ERR = 0;

  /// < infos
  static const int AUBIO_LOG_INF = 1;

  /// < general messages
  static const int AUBIO_LOG_MSG = 2;

  /// < debug messages
  static const int AUBIO_LOG_DBG = 3;

  /// < warnings
  static const int AUBIO_LOG_WRN = 4;

  /// < number of valid levels
  static const int AUBIO_LOG_LAST_LEVEL = 5;
}

/// Logging function prototype, to be passed to ::aubio_log_set_function
///
/// \param level log level
/// \param message text to log
/// \param data optional closure used by the callback
///
/// See @ref utils/test-log.c for an example of logging function.
typedef aubio_log_function_t
    = ffi.Pointer<ffi.NativeFunction<aubio_log_function_tFunction>>;
typedef aubio_log_function_tFunction = ffi.Void Function(
    sint_t level, ffi.Pointer<char_t> message, ffi.Pointer<ffi.Void> data);
typedef Dartaubio_log_function_tFunction = void Function(
    Dartsint_t level, ffi.Pointer<char_t> message, ffi.Pointer<ffi.Void> data);

/// Error reporting
abstract class aubio_status {
  static const int AUBIO_OK = 0;
  static const int AUBIO_FAIL = 1;
}

final class _aubio_pitchyin_t extends ffi.Struct {
  external ffi.Pointer<fvec_t> yin;

  @smpl_t()
  external double tol;

  @uint_t()
  external int peak_pos;
}

/// pitch detection object
typedef aubio_pitchyin_t = _aubio_pitchyin_t;

final class _aubio_pitchfcomb_t extends ffi.Struct {
  @uint_t()
  external int fftSize;

  @uint_t()
  external int stepSize;

  @uint_t()
  external int rate;

  external ffi.Pointer<fvec_t> winput;

  external ffi.Pointer<fvec_t> win;

  external ffi.Pointer<cvec_t> fftOut;

  external ffi.Pointer<fvec_t> fftLastPhase;

  external ffi.Pointer<aubio_fft_t> fft;
}

/// pitch detection object
typedef aubio_pitchfcomb_t = _aubio_pitchfcomb_t;

/// pitch yinfft structure
final class _aubio_pitchyinfft_t extends ffi.Struct {
  /// < temporal weighting window
  external ffi.Pointer<fvec_t> win;

  /// < windowed spectrum
  external ffi.Pointer<fvec_t> winput;

  /// < square difference function
  external ffi.Pointer<fvec_t> sqrmag;

  /// < spectral weighting window (psychoacoustic model)
  external ffi.Pointer<fvec_t> weight;

  /// < Fourier transform output
  external ffi.Pointer<fvec_t> fftout;

  /// < fft object to compute square difference function
  external ffi.Pointer<aubio_fft_t> fft;

  /// < Yin function
  external ffi.Pointer<fvec_t> yinfft;

  /// < Yin tolerance
  @smpl_t()
  external double tol;

  /// < currently selected peak pos
  @uint_t()
  external int peak_pos;

  @uint_t()
  external int short_period;
}

/// pitch detection object
typedef aubio_pitchyinfft_t = _aubio_pitchyinfft_t;

/// pitch specacf structure
final class _aubio_pitchspecacf_t extends ffi.Struct {
  /// < temporal weighting window
  external ffi.Pointer<fvec_t> win;

  /// < windowed spectrum
  external ffi.Pointer<fvec_t> winput;

  /// < fft object to compute
  external ffi.Pointer<aubio_fft_t> fft;

  /// < Fourier transform output
  external ffi.Pointer<fvec_t> fftout;

  /// < square magnitudes
  external ffi.Pointer<fvec_t> sqrmag;

  /// < auto correlation function
  external ffi.Pointer<fvec_t> acf;

  /// < tolerance
  @smpl_t()
  external double tol;

  /// < confidence
  @smpl_t()
  external double confidence;
}

/// pitch detection object
typedef aubio_pitchspecacf_t = _aubio_pitchspecacf_t;

final class _aubio_pitchschmitt_t extends ffi.Struct {
  @uint_t()
  external int blockSize;

  @uint_t()
  external int rate;

  external ffi.Pointer<ffi.Short> schmittBuffer;

  external ffi.Pointer<ffi.Short> schmittPointer;

  external ffi.Pointer<ffi.Short> buf;
}

/// pitch detection object
typedef aubio_pitchschmitt_t = _aubio_pitchschmitt_t;

final class _aubio_pitchyinfast_t extends ffi.Struct {
  external ffi.Pointer<fvec_t> yin;

  @smpl_t()
  external double tol;

  @uint_t()
  external int peak_pos;

  external ffi.Pointer<fvec_t> tmpdata;

  external ffi.Pointer<fvec_t> sqdiff;

  external ffi.Pointer<fvec_t> kernel;

  external ffi.Pointer<fvec_t> samples_fft;

  external ffi.Pointer<fvec_t> kernel_fft;

  external ffi.Pointer<aubio_fft_t> fft;
}

/// pitch detection object
typedef aubio_pitchyinfast_t = _aubio_pitchyinfast_t;

final class _aubio_pitchmcomb_t extends ffi.Struct {
  /// < offset threshold [0.033 or 0.01]
  @smpl_t()
  external double threshold;

  /// < normalisation exponent [9]
  @smpl_t()
  external double alpha;

  /// < low-pass filter cutoff [0.34, 1]
  @smpl_t()
  external double cutoff;

  /// < tolerance [0.05]
  @smpl_t()
  external double tol;

  /// < median filter window length
  @uint_t()
  external int win_post;

  /// < median filter window
  @uint_t()
  external int win_pre;

  /// < maximum number of candidates (combs)
  @uint_t()
  external int ncand;

  /// < maximum number of partials per combs
  @uint_t()
  external int npartials;

  /// < picked picks
  @uint_t()
  external int count;

  /// < best candidate
  @uint_t()
  external int goodcandidate;

  /// < spectrum partition to consider
  @uint_t()
  external int spec_partition;

  /// < up to length win/spec_partition
  external ffi.Pointer<aubio_spectralpeak_t> peaks;

  external ffi.Pointer<ffi.Pointer<aubio_spectralcandidate_t>> candidates;

  /// < vec to store mag
  external ffi.Pointer<fvec_t> newmag;

  /// < vec to store modified mag
  external ffi.Pointer<fvec_t> scratch;

  /// < vec to compute moving median
  external ffi.Pointer<fvec_t> scratch2;

  /// < vec to store phase
  external ffi.Pointer<fvec_t> theta;

  @smpl_t()
  external double phasediff;

  @smpl_t()
  external double phasefreq;
}

typedef aubio_spectralpeak_t = _aubio_spectralpeak_t;

/// spectral peak object
final class _aubio_spectralpeak_t extends ffi.Struct {
  /// < bin [0-(length-1)]
  @uint_t()
  external int bin;

  /// < estimated bin
  @smpl_t()
  external double ebin;

  /// < peak magnitude
  @smpl_t()
  external double mag;
}

typedef aubio_spectralcandidate_t = _aubio_spectralcandidate_t;

/// spectral candidates array object
final class _aubio_spectralcandidate_t extends ffi.Struct {
  /// < interpolated bin
  @smpl_t()
  external double ebin;

  /// < comb
  external ffi.Pointer<smpl_t> ecomb;

  /// < candidate energy
  @smpl_t()
  external double ene;

  /// < length
  @smpl_t()
  external double len;
}

/// pitch detection object
typedef aubio_pitchmcomb_t = _aubio_pitchmcomb_t;

final class _aubio_audio_unit_t extends ffi.Opaque {}

typedef aubio_audio_unit_t = _aubio_audio_unit_t;
typedef aubio_device_callback_t
    = ffi.Pointer<ffi.NativeFunction<aubio_device_callback_tFunction>>;
typedef aubio_device_callback_tFunction = uint_t Function(
    ffi.Pointer<ffi.Void> closure,
    ffi.Pointer<fmat_t> ibuf,
    ffi.Pointer<fmat_t> obuf);
typedef Dartaubio_device_callback_tFunction = Dartuint_t Function(
    ffi.Pointer<ffi.Void> closure,
    ffi.Pointer<fmat_t> ibuf,
    ffi.Pointer<fmat_t> obuf);

/// TODO fallback time stretching implementation
final class _aubio_timestretch_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> dummy;
}

/// time stretching object
typedef aubio_timestretch_t = _aubio_timestretch_t;

/// TODO fallback pitch shifting implementation
final class _aubio_pitchshift_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> dummy;
}

/// pitch shifting object
typedef aubio_pitchshift_t = _aubio_pitchshift_t;

const int HAVE_AUBIO_DOUBLE = 0;

const String AUBIO_SMPL_FMT = '%f';

const String AUBIO_LSMP_FMT = '%lf';

const int HAVE_NOOPT = 1;

const int AUBIO_UNSTABLE = 1;

const int AUBIO_MAX_SAMPLERATE = 1536000;

const int AUBIO_MAX_CHANNELS = 1024;

const double PI = 3.141592653589793;

const double TWO_PI = 6.283185307179586;

const int PATH_MAX = 1024;

const double VERY_SMALL_NUMBER = 2e-42;
